<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta content="width=device-width,initial-scale=1" name="viewport" />
    <title>Time Ontology in OWL</title>
    <script class="remove" src="http://www.w3.org/Tools/respec/respec-w3c-common"></script>
    <script class="remove" src="config.js"></script>

<style type="text/css">

/* Table styles, March 2016 */

table {border-collapse:collapse}
th, td {
  border:thin solid black;
  padding: 0.3em;
}

.inlineCode {
	FONT-FAMILY: "courier new"; BACKGROUND-COLOR: #ddf
}
PRE.code {
	BORDER-RIGHT: #999999 1pt solid; PADDING-RIGHT: 0.5em; BORDER-TOP: #999999 1pt solid; PADDING-LEFT: 0.5em; PADDING-BOTTOM: 0.5em; BORDER-LEFT: #999999 1pt solid; PADDING-TOP: 0.5em; BORDER-BOTTOM: #999999 1pt solid; FONT-FAMILY: "courier new"; BACKGROUND-COLOR: #eef
}
PRE.code2 {
	BORDER-RIGHT: #999999 1pt solid; PADDING-RIGHT: 0.5em; BORDER-TOP: #999999 1pt solid; PADDING-LEFT: 0.5em; PADDING-BOTTOM: 0.5em; BORDER-LEFT: #999999 1pt solid; PADDING-TOP: 0.5em; BORDER-BOTTOM: #999999 1pt solid; FONT-FAMILY: "courier new"; BACKGROUND-COLOR: #ffa
}
.ednote {
	FONT-STYLE: italic
}
PRE.clientmsg {
	BORDER-RIGHT: #999 1px solid; PADDING-RIGHT: 2px; BORDER-TOP: #999 1px solid; PADDING-LEFT: 2px; BACKGROUND: #eee; PADDING-BOTTOM: 2px; MARGIN: 0px; BORDER-LEFT: #999 1px solid; PADDING-TOP: 2px; BORDER-BOTTOM: #999 1px solid
}
PRE.servermsg {
	BORDER-RIGHT: #999 1px solid; PADDING-RIGHT: 2px; BORDER-TOP: #999 1px solid; PADDING-LEFT: 2px; BACKGROUND: #eee; PADDING-BOTTOM: 2px; MARGIN: 5px 0px 0px; BORDER-LEFT: #999 1px solid; PADDING-TOP: 2px; BORDER-BOTTOM: #999 1px solid; TEXT-ALIGN: left
}
P.msg {
	PADDING-RIGHT: 0px; PADDING-LEFT: 0px; PADDING-BOTTOM: 0px; MARGIN: 0px; PADDING-TOP: 0px; TEXT-ALIGN: center
}
DIV.interaction {
	BORDER-RIGHT: #999 1px solid; PADDING-RIGHT: 5px; BORDER-TOP: #999 1px solid; PADDING-LEFT: 5px; PADDING-BOTTOM: 5px; BORDER-LEFT: #999 1px solid; PADDING-TOP: 5px; BORDER-BOTTOM: #999 1px solid
}
DIV.interaction H4 {
	MARGIN: 0px 0px 10px
}
DIV.interaction P {
	MARGIN: 0px
}
DIV.test {
	BORDER-RIGHT: #999 1px solid; PADDING-RIGHT: 5px; BORDER-TOP: #999 1px solid; PADDING-LEFT: 5px; PADDING-BOTTOM: 5px; BORDER-LEFT: #999 1px solid; PADDING-TOP: 5px; BORDER-BOTTOM: #999 1px solid
}
DIV.test H4 {
	MARGIN: 0px 0px 10px
}
</style>
</head>
<BODY>

    <section id="abstract">
      <p>This document presents an ontology of temporal concepts, OWL-Time (formerly 
DAML-Time) [<a href="#ref-4">4</a>,<a href="#ref-10">10</a>], 
for describing the temporal content of Web pages and the temporal properties of 
Web services. The ontology provides a vocabulary for expressing facts about 
topological relations among instants and intervals, together with information 
about durations, and about datetime information. We also demonstrate in detail, 
using the Congo.com and Bravo Air examples from OWL-S [<a href="#ref-11">11</a>], 
how this time ontology can be used to support OWL-S, including use cases for defining input parameters and (conditional) output parameters. A use case for 
meeting scheduling is also shown. In the appendix we also describe a time zone 
resource in OWL we developed for not only the US but also the entire world, 
including the time zone ontology, the US time zone instances, and the world time 
zone instances.</p>
    </section>


    <section id="sotd"><p>Add at least one line specific to this doc.</p></section>


<section id="general"><h2>General issues</h2>
<P>Temporal information is so common that it’s hard to find a real world Web 
service without it. For example, whenever you place an online order, the order 
date is always part of your order. When you reserve a car at a car rental site, 
you have to specify the dates you need it. In response to this need, a temporal 
ontology, OWL-Time (formerly DAML-Time), has been developed for describing the 
temporal content of Web pages and the temporal properties of Web services. Its 
development is being informed by temporal ontologies developed at a number of 
sites and is intended to capture the essential features of all of them and make 
them and their associated resources easily available to a large group of Web 
developers and users.&nbsp;Although it can be used independently, we have made 
sure it works well with OWL-S. Advantages of OWL-Time over XML Schema datatype 
<CODE>duration</CODE> and <CODE>dateTime</CODE> will be discussed.</P>
<P>This document only presents the OWL encodings of the ontology. For a 
first-order logic axiomatization of the ontology, see [<a href="#ref-4">4</a>,<a href="#ref-10">10</a>]. 
In an extension of the time ontology [<a href="#ref-5">5</a>,<a href="#ref-9">9</a>], 
we also allow temporal predicates to apply directly to events, should the user 
wish, but here we restrict our treatment to temporal entities. </P>
</section>

<section id="examples"><h2>Use case examples</h2>
<P>A simple use case example: "Suppose someone has a telecon scheduled for 
6:00pm EST on November 5, 2006. You would like to make an appointment with him 
for 2:00pm PST on the same day, and expect the meeting to last 45 minutes.&nbsp; 
Will there be an overlap?" In this use case we can specify the facts about the 
telecon and the meeting using our ontology in OWL that will allow a temporal 
reasoner to determine whether there is a conflict. See [<A 
href="#scheduling">A 
Use Case for Scheduling</A>] section for details.</P>
<P>More examples: "Someone who does a Web search trying to find a place to buy a 
book needed before next Tuesday may or may not be able to use an online 
bookstore that promises delivery within five business days." </P>
<P>"Someone doing a genealogical search may want to specify that the birthdate 
of a person is between 15 and 45 years before a known marriage date."</P>
<P>More use case examples will be described in detail in [<A 
href="#ref-time-in-owl-s">Use 
Cases for Web Services</A>] section below. </P>
</section>

<section id="syntax"><h2>Syntax for code</h2>
<P>In keeping with SWBP policy, the code within the body of the note is in N3. 
Most of the code was generated by Prot&eacute;g&eacute; from the original OWL code in RDF/XML. 
Details in alternative syntaxes are given by links.</P>
</section>
<HR>


<section id="relations"><h2>Topological Temporal Relations</h2>
<P>There are two subclasses of <CODE>TemporalEntity</CODE>: <CODE>Instant</CODE> 
and <CODE>Interval</CODE>, and they are the only two subclasses of 
<CODE>TemporalEntity</CODE>:</P>
<PRE>:Instant
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; owl:Class ;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rdfs:subClassOf :TemporalEntity .</PRE><PRE>:Interval
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; owl:Class ;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rdfs:subClassOf :TemporalEntity .</PRE><PRE>:TemporalEntity
      a       owl:Class ;
      rdfs:subClassOf :TemporalThing ;
      owl:equivalentClass
              [ a       owl:Class ;
                owl:unionOf (:Instant :Interval)
              ] .</PRE>
<P>Intervals are, intuitively, things with extent and instants are, intuitively, 
point-like in that they have no interior points. It is generally safe to think 
of an instant as an interval with zero length, where the beginning and end are 
the same.</P>
<P><CODE>hasBeginning</CODE> and <CODE>hasEnd</CODE> are relations between 
instants and temporal entities, and the beginnings and ends of temporal 
entities, if they exist, are unique. In some approach to infinite intervals, a 
positively infinite interval has no end, and a negatively infinite interval has 
no beginning. Hence, we use the relations <CODE>hasBeginning</CODE> and 
<CODE>hasEnd</CODE> in the ontology, rather than defining functions 
<CODE>beginningOf</CODE> and <CODE>endOf</CODE>, since the functions would not 
be total. <CODE>hasBeginning</CODE>, for example, can be specified as:</P><PRE>:hasBeginning
      a       owl:ObjectProperty ;
      rdfs:domain :TemporalEntity ;
      rdfs:range :Instant .</PRE>
<P><CODE>inside</CODE> is a relation between an instant and an interval, and it 
is not intended to include beginnings and ends of intervals.&nbsp;There is a 
<CODE>before</CODE> relation on temporal entities, which gives directionality to 
time. If a temporal entity <CODE>T<SUB>1</SUB></CODE> is before another temporal 
entity <CODE>T<SUB>2</SUB></CODE>, then the end of <CODE>T<SUB>1</SUB></CODE> is 
before the beginning of <CODE>T<SUB>2</SUB></CODE>. Thus, before can be 
considered to be basic to instants and derived for intervals.&nbsp;</P>
<P>Allen and Furgerson [<A 
href="#ref-1">1</A>,<A 
href="#ref-2">2</A>] 
have developed a calculus of binary relations on intervals (e.g., meets, 
overlaps) for representing qualitative temporal information and address the 
problem of reasoning about such information. The relations between intervals 
defined in their calculus can be defined in a relatively straightforward fashion 
in terms of <CODE>before</CODE> and identity on the beginning and end points. 
The standard interval calculus assumes all intervals are proper, and we do that 
here too. Proper intervals are ones whose beginning and end are different. It 
can be specified as:</P><PRE>:ProperInterval
      a       owl:Class ;
      rdfs:subClassOf :Interval ;
      owl:disjointWith :Instant .</PRE>
<P>OWL-Time provides the interval relations: <CODE>intervalEquals</CODE>, 
<CODE>intervalBefore</CODE>, <CODE>intervalMeets</CODE>, 
<CODE>intervalOverlaps</CODE>, <CODE>intervalStarts</CODE>, 
<CODE>intervalDuring</CODE>, <CODE>intervalFinishes</CODE>, and their reverse 
interval relations: <CODE>intervalAfter</CODE>, <CODE>intervalMetBy</CODE>, 
<CODE>intervalOverlappedBy</CODE>, <CODE>intervalStartedBy</CODE>, 
<CODE>intervalContains</CODE>, <CODE>intervalFinishedBy</CODE>. For example, the 
specification of <CODE>intervalEquals</CODE> is:</P><PRE>:<CODE>interval</CODE>Equals
      a       owl:ObjectProperty ;
      rdfs:domain :ProperInterval ;
      rdfs:range :ProperInterval .</PRE>
</section>

<section id="duration"><h2>Duration Description</h2>
<P>The duration of an interval (or temporal sequence) can have many different 
descriptions. An interval can be 1 day 2 hours, or 26 hours, or 1560 minutes, 
and so on. It is useful to be able to talk about these descriptions in a 
convenient way as independent objects, and to talk about their equivalences. We 
do this first in terms of a predicate called <CODE>durationOf</CODE> that takes 
eight arguments, one for a temporal thing, and one each for years, months, 
weeks, days, hours, minutes, and seconds. Then we will define a specific kind of 
individual called a "duration description", together with a number of functions 
relating the duration description to the values of each of the eight arguments. 
Thereby we convert the 8-ary predicate <CODE>durationOf</CODE> into eight binary 
relations that are more convenient for description logic-based markup languages, 
such as OWL:</P><PRE>:DurationDescription
      a       owl:Class ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :seconds
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :minutes
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :hours
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :days
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :weeks
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :months
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :years
              ] .</PRE>
<P>An interval can have multiple duration descriptions (e.g., 2 days, 48 hours), 
but can only have one duration. </P>
<P>We use two different sets of properties for <CODE>DateTimeDescription</CODE> 
and <CODE>DurationDescription</CODE>, because their ranges are different. For 
example, <CODE>year</CODE> (in <CODE>DateTimeDescription</CODE>) has a range of 
<CODE>xsd:gYear</CODE>, while <CODE>years</CODE> (in 
<CODE>DurationDescription</CODE>) has a range of <CODE>xsd:decimal</CODE> so 
that you can say duration of 2.5 years.</P>
<P>iCalendar [<a href="#ref-3">3</a>] 
is a widely supported standard for personal data interchange. It provides the 
definition of a common format for openly exchanging calendaring and scheduling 
information across the Internet. The representation of temporal concepts in this 
time ontology can be straightforwardly mapped to iCalendar. For example, 
duration of 15 days, 5 hours and 20 seconds is represented in iCalendar as 
P15DT5H0M20S, which can be represented in the time ontology as:</P><PRE>:duration
      a       :DurationDescription ;
      :seconds 20 ;
      :hours 5 ;
      :days 15 .
</PRE>
<P><A name=ref-duration></A>The relation <CODE>hasDurationDescription</CODE> is 
used to specify a duration description for a temporal entity:</P><PRE>:hasDurationDescription
      a       owl:ObjectProperty ;
      rdfs:domain :TemporalEntity ;
      rdfs:range :DurationDescription .</PRE>
<P>Other duration concepts can be straightforwardly defined. For example, 
duration "Year" can be defined as a subclass of "DurationDescription" with the 
restrictions that the "years" property is required (with "cardinality" of 1) and 
all other properties (e.g., "hours", "months") should not be present (with 
"cardinality" of 0):<BR><PRE>:Year
      a       owl:Class ;
      rdfs:subClassOf :DurationDescription ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:cardinality 1 ;
                owl:onProperty :years
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:cardinality 0 ;
                owl:onProperty :months
              ] ;
      ...

      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:cardinality 0 ;
                owl:onProperty :seconds
              ] .
</PRE>Here we use "cardinality = 0" instead of restricting the values of days, 
etc. to 0. The reason is that using "cardinality = 0" means all those 
properties/fields (days, etc.) should not be specified (i.e., the granularity is 
"year"), while restricting all those values to 0 means they all have a fixed 
value of 0 (i.e., x years 0 months 0 days ...) and the granularity is actually 
"second", which is not the correct semantics of "year".
<P>It's worth pointing out that there is a distinction between a year as a 
duration and a calendar year. The year from December 22, 2006 to December 21, 
2007 is the former but not the latter.</P>
</section>

<section id="timezones"><h2>Time Zones</h2>
<P>What hour of the day an instant is in is relative to the time zone. This is 
also true of minutes, since there are regions in the world, e.g., central 
Australia, where the hours are not aligned with UTC hours, but are, e.g., offset 
half an hour. Seconds are not relative to the time zone.</P>
<P>Days, weeks, months and years are also relative to the time zone, since, 
e.g., 2006 began in the Eastern Standard time zone three hours before it began 
in the Pacific Standard time zone. Thus, predications about all datetime 
intervals except seconds are relative to a time zone. </P>
<P>We have been referring to time zones, but in fact it is more convenient to 
work in terms of what we might call the "time standard" that is used in a time 
zone. That is, it is better to work with the Pacific Standard Time (PST) as a 
legal entity than with the PST zone as a geographical region. A time standard is 
a way of computing the time, relative to a world-wide system of computing time. 
For each time standard, there is a zone, or geographical region, and a time of 
the year in which it is used for describing local times. Where and when a time 
standard is used have to be axiomatized, and this involves interrelating a time 
ontology and a geographical ontology. These relations can be quite complex. Only 
the entities like PST and EDT, the time standards, are part of the time 
ontology.</P>
<P>If we were to conflate time zones (i.e., geographical regions) and time 
standards, it would likely result in problems in several situations. For 
example, the Eastern Standard zone and the Eastern Daylight zone are not 
identical, since most of Indiana was on Eastern Standard time all year. The state 
of Arizona and the Navajo Indian Reservation, two overlapping geopolitical 
regions, have different time standards during the daylight saving times -- one 
is Pacific and the other is Mountain.</P>
<P>Time standards that seem equivalent, like Eastern Standard and Central 
Daylight, should be thought of as separate entities. Whereas they function the 
same in the time ontology, they do not function the same in the ontology that 
articulates time and geography. For example, it would be false to say those 
parts of Indiana shifted in April from Eastern Standard to Central Daylight 
time.</P>
<P>See [<a href="#timezone">Appendix B</a>] for the details about a 
time zone resource we developed in OWL. </P>
</section>

<section id="calclock"<h2>DateTime Description</h2>
<P>A datetime description has the following properties/fields: 
<CODE>unitType</CODE>, <CODE>year</CODE>, <CODE>month</CODE>, <CODE>week</CODE>, 
<CODE>day</CODE>, <CODE>dayOfWeek</CODE>, <CODE>dayOfYear</CODE>, 
<CODE>hour</CODE>, <CODE>minute</CODE>, <CODE>second</CODE>, and 
<CODE>timeZone</CODE>. The property <CODE>unitType</CODE> specifies the temporal 
unit type of the datetime description, and its domain is 
<CODE>TemporalUnit</CODE>:</P><PRE>:TemporalUnit
      a       owl:Class ;
      owl:equivalentClass
              [ a       owl:Class ;
                owl:oneOf (:unitSecond :unitMinute :unitHour :unitDay :unitWeek :unitMonth :unitYear)
              ] .
</PRE>
<P>For example, the temporal unit type of 10:30 is minute 
(<CODE>unitMinute</CODE>), and the temporal unit type of March 20, 2006 is day 
(<CODE>unitDay</CODE>). The unit type is required. With a given temporal unit 
type, all the fields/properties for smaller units will be ignored. For instance, 
if the temporal unit type is day (<CODE>unitDay</CODE>), the values of the 
field/property hour, minute, and second, if present, will be ignored. Since 
datetime description is for describing datetime intervals, we defined a 
property, called <CODE>hasDateTimeDescription</CODE> with 
<CODE>DateTimeDescription</CODE> as the range, for datetime intervals. To 
represent "March 12 in 2006", for example, using datetime description, we need 
an instance of <CODE>DateTimeDescription</CODE> that has values only for 
<CODE>unitType</CODE>(<CODE>unitDay</CODE>), <CODE>year</CODE>(2006), 
<CODE>month</CODE>(3), and <CODE>day</CODE>(12). 
<CODE>DateTimeDescription</CODE> and <CODE>hasDateTimeDescription</CODE> are 
defined in OWL as:</P><PRE>:DateTimeDescription
      a       owl:Class ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:cardinality 1 ;
                owl:onProperty :unitType
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :second
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :minute
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :hour
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :day
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :dayOfWeek
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :dayOfYear
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :week
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :month
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :year
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :timeZone
              ] .
              
:hasDateTimeDescription
      a       owl:ObjectProperty ;
      rdfs:domain :DateTimeInterval ;
      rdfs:range :DateTimeDescription .
</PRE>
<P><CODE>DateTimeInterval</CODE> is a subclass of <CODE>ProperInterval</CODE>. 
Any <CODE>TemporalEntity</CODE> has a duration, but only 
<CODE>DateTimeInterval</CODE> can have <CODE>DateTimeDescription</CODE> (e.g., 
May 8 has a <CODE>DateTimeDescription</CODE>, but the interval from 1:30pm, May 
8, to 1:30pm, May 9, does not. Both have a duration of a day. A 
<CODE>DateTimeDescription</CODE> is always a description of an interval 
(<CODE>DateTimeInterval</CODE>), not an instant, which can be described 
by&nbsp;<CODE>inDateTime</CODE> and <CODE>inXSDDateTime</CODE>, as described 
later in the section.
<P>The domain of the property <CODE>dayOfWeek</CODE> is the class 
<CODE>DayOfWeek</CODE>:<PRE>:DayOfWeek
      a       owl:Class ;
      owl:equivalentClass
              [ a       owl:Class ;
                owl:oneOf (:Sunday :Monday :Tuesday :Wednesday :Thursday :Friday :Saturday)
              ] .
</PRE>
<P><A name=calclock></A>Other datetime concepts can be straightforwardly defined. 
For example, "January" can be defined as a a subclass of 
<CODE>DateTimeDescription</CODE> with the restrictions that the 
<CODE>unitType</CODE> property has <CODE>allValuesFrom</CODE> unitMonth and 
property <CODE>month</CODE> <CODE>hasValue</CODE> of 1:<BR><PRE>:January
      a       owl:Class ;
      rdfs:subClassOf :DateTimeDescription ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:onProperty :unitType
                owl:hasValue :unitMonth
              ] ;
     rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:onProperty :month
                owl:hasValue --01 ;
              ] .
</PRE>
<P>In order to specify that an instant is in a datetime interval, an 
<CODE>inDateTime</CODE> property/relation is defined similarly to 
<CODE>hasDateTimeDescription</CODE> as follows:</P><PRE>:inDateTime
      a       owl:ObjectProperty ;
      rdfs:domain :Instant ;
      rdfs:range :DateTimeDescription .
</PRE>
<P>With this <CODE>inDateTime</CODE> relation, we can say that an instant 
happens at a specific time. For example, the beginning of a meeting, which is an 
instant, is at 6:00pm which is actually in a datetime interval of [6:00:00, 
6:01:00). With <CODE>inDateTime</CODE> you do not describe instants; you only 
approximate them by confining them within an interval. This should generally be 
adequate. Where it is not, you can always define an instant in a roundabout way 
as the beginning of an interval.</P>
<P><A name=ref-datetime></A>We also defined in OWL two simpler relations, 
<CODE>xsdDateTime</CODE> and <CODE>inXSDDateTime</CODE>. The only difference 
between these two relations and the above <CODE>hasDateTimeDescription</CODE> and 
<CODE>inDateTime</CODE> relations is their ranges: these two simpler relations 
use the XML Schema datatype <CODE>dateTime</CODE> as their ranges, while the 
above uses <CODE>DateTimeDescription</CODE>:</P><PRE>:xsdDateTime
      a       owl:DatatypeProperty ;
      rdfs:domain :DateTimeInterval ;
      rdfs:range xsd:dateTime .

:inXSDDateTime
      a       owl:DatatypeProperty ;
      rdfs:domain :Instant ;
      rdfs:range xsd:dateTime .
</PRE>
<P>To illustrate more clearly the difference between using 
<CODE>DateTimeDescription </CODE>and using the XML datatype 
<CODE>dateTime</CODE>, let’s look at a concrete example: an instant that 
represents the start of a meeing, called <CODE>meetingStart</CODE>, happens at 
10:30am EST on 01/01/2006 can be expressed using both <CODE>inXSDDateTime</CODE> 
and <CODE>inDateTime</CODE> in OWL as:</P><PRE>:meetingStart
      a       :Instant ;
      :inDateTime
              :meetingStartDescription ;
      :inXSDDateTime
              2006-01-01T10:30:00-5:00 .

:meetingStartDescription
      a       :DateTimeDescription ;
      :unitType :unitMinute ;
      :minute 30 ;
      :hour 10 ;
      :day 1 ;
      :dayOfWeek :Sunday ;
      :dayOfYear 1 ;
      :week 1 ;
      :month 1 ;
      :timeZone tz-us:EST ;
      :year 2006 .</PRE>
<P>We can see from this example that it’s much more concise to use the XML 
Schema datatype <CODE>dateTime</CODE>. However, the advantage of using 
<CODE>DateTimeDescription </CODE>is that it can express more information than 
<CODE>dateTime</CODE>, such as "week", "day of week" and "day of year", so in 
the above example, we can also know that 01/01/2006 is Sunday, on the first 
day of the year, and in the first week of the year. </P>
<P>The namespace “tz-us” points to our US time zone data [<A 
href="#ref-17">17</A>]. 
Moreover, each field of <CODE>DateTimeDescription </CODE>is separate so that 
it's easier to extract the value of some fields for the later use and easier to 
reason about.</P>

<section id="time-ontology-code"><h3>OWL code for the time ontology </h3>
<P>[<A href="/2006/time">RDF/XML</A>] </P></section>
</section>

<section id="ref-time-in-owl-s"><h2>Use Cases for Web Services</h2>
<P>Congo.com and Bravo Air are the two examples used in the OWL-S 0.9 draft 
release [<A 
href="#ref-12">12</A>] 
(the most recent release is OWL-S 1.1 [<A 
href="#ref-13">13</A>], 
and we use code in 0.9 draft release here for illustrative purpose). Congo.com 
is a fictitious book-selling service site, and Bravo Air is a fictitious 
airline-ticketing service site. We use these two examples to demonstrate in 
detail how the time ontology can be used to support OWL-S, including use cases 
for defining input parameters and (conditional) output parameters. </P>

<section id="input"><h3>Use Cases for Input Parameters</h3>
<P>In the profile of the Congo.com example (i.e. CongoProfile.owl), for example, 
our time ontology is currently used for describing the input parameter 
<CODE>CreditCardExpirationDate</CODE>:</P><PRE>profile:CreditCardExpirationDate
      a       profile:ParameterDescription ;
      profile:parameterName
              creditCardExpirationDate ;
      profile:restrictedTo
              time:<B>Instant</B> ;
      profile:referTo
              congoProcess:creditCardExpirationDate .</PRE>
<P>The namespace “time” points to the location of the OWL code for the time 
ontology. In this example <CODE>Instant</CODE> is used to describe 
<CODE>CreditCardExpirationDate</CODE>, because the expiration date is actually 
an instant -- the midnight, of the day the credit card expires. </P>
<P>In the Bravo Air example, our time ontology can be used to describe the 
existing input parameters, <CODE>DepartureDate</CODE> and 
<CODE>ArrivalDate</CODE>. We will change this to the more appropriate 
<CODE>DepartureTime</CODE> and <CODE>ArrivalTime</CODE>. We can define 
<CODE>DepartureTime</CODE> in the profile of the Bravo Air example (i.e. 
BravoAirProfile.owl) as: </P><PRE>profile:DepartureTime
      a       profile:ParameterDescription ;
      profile:parameterName
              DepartureTime ;
      profile:restrictedTo
              time:<B>Instant</B> ;
      profile:referTo
              ba_process:outboundDate_In .</PRE>
<P><CODE>DepartureTime</CODE> is defined as <CODE>Instant</CODE>. With this 
definition, as we discussed in the previous datetime description section, an 
instance of <CODE>DepartureTime</CODE> can has either an 
<CODE>inXSDDateTime</CODE> property/relation pointing to a specific value of XML 
Schema datatype dateTime, say 2006-01-01T10:30:00-5:00, or an 
<CODE>inDateTime</CODE> object-property/relation pointing to an instance of 
<CODE>DateTimeDescription</CODE> class specifying a specific time, say 10:30am 
EST on 01/01/2006, Sunday. It would be the user’s decision to define the time 
in either way based on the trade-offs discussed in the previous section.</P>
</section>

<section id="output"><h3>Use Cases for (Conditional) Output Parameters</h3>
<P>In fact, there is much more that our time ontology can do to support OWL-S. 
In the Congo.com and Bravo Air examples, the time ontology is not used for any 
output parameters. However, in the real world many service outputs are 
time-related. For example, in the Congo.com example we can add two outputs that 
are very common in real world book-selling sites: process time and delivery 
duration.</P>
<section id="ProcessTime"><h4>Adding a <CODE>ProcessTime</CODE> output parameter</h4>
<P><CODE>ProcessTime</CODE> is a conditional output parameter that specifies how 
long before the book will be ready for delivery, say, 24 hours, which depends on 
whether the book is in stock. In this use case, the process time is returned 
only if the book is in stock. It can be defined in the process model of the 
Congo.com example (i.e. CongoProcess.owl) as:</P><PRE>:ProcessTime
      a       owl:Class ;
      rdfs:subClassOf time:<B>Interval</B> .

:fullCongoBuyProcessTime
      a       rdf:Property ;
      rdfs:subPropertyOf process:output ;
      rdfs:domain :FullCongoBuy ;
      rdfs:range       
	      [ a       owl:Class ;
      		rdfs:subClassOf process:ConditionalOutput ;
      		rdfs:subClassOf
              		[ a       owl:Restriction ;
                	owl:allValuesFrom :BookInStock ;
                	owl:onProperty process:coCondition
              		] ;
	      ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:allValuesFrom :<B>ProcessTime</B> ;
                owl:onProperty process:coOutput
              ] .</PRE>
<P><CODE>ProcessTime</CODE> is defined as an interval, rather than a duration. 
As discussed previously, in our time ontology durations are properties of 
intervals. Thus to talk about a duration, i.e. a quantity of time, an interval 
must be defined first. This approach may look roundabout at first glance. 
However, the process time is not purely a quantity of time; it has a location on 
the time line. The beginning of the process time is the time the user places the 
order, and the end of the process time is the time the order is shipped out. An 
advantage of defining <CODE>ProcessTime</CODE> as an interval is that if the 
relationship among the order time, the shipping time, and the process time is 
known, any one of them (e.g. the shipping time) can be computed from the other 
two (e.g. the order time and the process time) by temporal arithmetic. </P>
</section>

<section id="DeliveryDuration"><h4>Adding a <CODE>DeliveryDuration</CODE> output parameter</h4>
<P><CODE>DeliveryDuration</CODE> is a conditional output parameter that 
specifies how long it will take for the customer to receive the book after it is 
shipped out, which depends on the delivery type the customer selects. As defined 
in the process model of the Congo.com example (i.e. CongoProcess.owl), the 
current delivery types are FedExOneDay, FedEx2-3day, UPS, and OrdinaryMail. </P>
<P>To add this output parameter may seem similar to the above 
<CODE>ProcessTime</CODE> example. However, since an instance of 
<CODE>Condition</CODE> is a logical formula that evaluates to true or false (see 
the comment with the definition of Condition [<A 
href="#ref-14">14</A>]), 
<CODE>DeliveryType</CODE> cannot be directly used as a condition to determine 
the delivery duration. Thus one property and one condition are defined for each 
delivery type. </P>
<P><CODE>DeliveryDuration</CODE> is defined with two boundaries: one 
<CODE>minDeliveryDuration</CODE> and one <CODE>maxDeliveryDuration</CODE>. For 
example, an order with the FedEx2-3day delivery type takes 2 to 3 days, so its 
min delivery duration is 2 days, and its max delivery duration is 3 days. For 
the delivery duration of the order with FedExOneDay delivery type, the min and 
max delivery duration will both be 1 day. We can define 
<CODE>DeliveryDuration</CODE> in the process model of the Congo.com example 
(i.e. CongoProcess.owl) as:</P><PRE>:DeliveryDuration
      a       owl:Class ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:cardinality 1 ;
                owl:onProperty :maxDeliveryDuration
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:cardinality 1 ;
                owl:onProperty :minDeliveryDuration
              ] .

:maxDeliveryDuration
      a       rdf:Property ;
      rdfs:domain :DeliveryDuration ;
      rdfs:range time:<B>Interval</B> .

:minDeliveryDuration
      a       rdf:Property ;
      rdfs:domain :DeliveryDuration ;
      rdfs:range time:<B>Interval</B> .
</PRE>
<P>Both <CODE>minDeliveryDuration</CODE> and <CODE>maxDeliveryDuration 
</CODE>are defined as properties of <CODE>DeliveryDuration</CODE>. For the same 
reason discussed for the process time example, both properties use Interval as 
their ranges. The cardinality of 1 for both properties in the definition of 
<CODE>DeliveryDuration</CODE> indicates that an instance of 
<CODE>DeliveryDuration</CODE> must have one and only one property value for 
<CODE>minDeliveryDuration</CODE> and <CODE>maxDeliveryDuration 
</CODE>respectively. For example, in order to define delivery duration for 
FedEx2-3day, we have to first define a condition of FedEx2-3day being 
selected:</P><PRE>:FedEx2-3dayCondition
      a       owl:Class ;
      rdfs:subClassOf process:Condition .</PRE>
<P>Then we define an output property, called 
<CODE>deliverySelectFedEx2-3day</CODE> that is conditional on 
<CODE>FedEx2-3dayCondition</CODE> defined above:</P><PRE>:deliverySelectFedEx2-3day
      a       rdf:Property ;
      rdfs:subPropertyOf process:output ;      
      rdfs:domain :SpecifyDeliveryDetails ;
      rdfs:range 
      	      [ a       owl:Class ;
      	      	rdfs:subClassOf process:ConditionalOutput ;
      	      	rdfs:subClassOf
              	      	[ a       owl:Restriction ;
                      	owl:allValuesFrom :FedEx2-3dayDuration ;
                      	owl:onProperty process:coOutput
              	      	] ;
      	      	rdfs:subClassOf
              	      	[ a       owl:Restriction ;
                      	owl:allValuesFrom :FedEx2-3dayCondition ;
                      	owl:onProperty process:coCondition
              ] .</PRE>
<P>This definition says that <CODE>deliverySelectFedEx2-3day</CODE> is a 
conditional output, and if <CODE>FedEx2-3dayCondition</CODE> is true, an 
instance of <CODE>FedEx2-3dayDuration</CODE> class will be the output. 
<CODE>FedEx2-3dayDuration</CODE> is not defined yet. In order to define it, we 
have to define its min delivery duration, i.e. 2 days, and max delivery 
duration, i.e. 3 days. Since the range of <CODE>minDeliveryDuration</CODE> and 
<CODE>maxDeliveryDuration</CODE> is <CODE>Interval</CODE>, intervals with 
specific durations need to be created first. For 
<CODE>FedEx2-3dayDuration</CODE>, we need to define <CODE>Interval2Days</CODE> 
and <CODE>Interval3Days</CODE> first as follows:</P><PRE>:Interval2Days
      a       owl:Class ;
      rdfs:subClassOf time:<B>Interval</B> ;
      owl:subClassOf
              [ a       owl:Restriction ;
                owl:hasValue P2D ;
                owl:onProperty time:<B>durationDescriptionDataType</B>
              ] .

:Interval3Days
      a       owl:Class ;
      rdfs:subClassOf time:<B>Interval</B> ;
      owl:subClassOf
              [ a       owl:Restriction ;
                owl:hasValue P3D ;
                owl:onProperty time:<B>durationDescriptionDataType</B>
              ] .</PRE>
<P>These two definitions use <CODE>durationDescriptionDataType</CODE>, a 
relatively simpler duration property of <CODE>Interval</CODE> using the XML 
Schmea datatype <CODE>duration</CODE> as its range. <CODE>P2D</CODE> and 
<CODE>P3D</CODE> are values of the XML Schema datatype <CODE>duration</CODE>, 
meaning 2 days and 3 days.</P>
<P>Finally, <CODE>FedEx2-3dayDuration</CODE> restricts the value of 
<CODE>minDeliveryDuration</CODE> and <CODE>maxDeliveryDuration</CODE> to class 
<CODE>Interval2Days</CODE> and <CODE>Interval3Days</CODE> respectively as 
follows:</P><PRE>:FedEx2-3dayDuration
      a       owl:Class ;
      rdfs:subClassOf :DeliveryDuration ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:allValuesFrom :Interval3Days ;
                owl:onProperty :maxDeliveryDuration
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:allValuesFrom :Interval2Days ;
                owl:onProperty :minDeliveryDuration
              ] .</PRE>
<P>Properties to output delivery durations when the user selects other delivery 
types (FedExOneDay, UPS, and OrdinaryMail) can be defined similarly.</P>
</section>
<section id="time-in-owls-09"><h4>OWL code for these examples</h4>
<P>[<A href="time-in-owls-09">RDF/XML</A>] </P></section>
</section>
</section>

<section id="scheduling"><h2>A Use Case for Scheduling</h2>
<P id="examples0">Suppose someone has a telecon scheduled for 6:00pm EST on November 5, 2006. 
You would like to make an appointment with him for 2:00pm PST on the same day, 
and expect the meeting to last 45 minutes.&nbsp; Will there be an overlap? </P>
<P>In this use case we can specify the facts about the telecon and the meeting 
using our ontology in OWL that will allow a temporal reasoner to determine 
whether there is a conflict:</P><PRE>:telecon
      a       :Interval ;
      :hasBeginning :teleconStart .
      
:meeting
      a       :Interval ;
      :hasBeginning :meetingStart ;
      :hasDurationDescription
              :meetingDuration .

:teleconStart
      a       :Instant ;
      :inXSDDateTime
              2006-11-05T18:00:00-5:00 .

:meetingStart
      a       :Instant ;
      :inXSDDateTime
              2006-11-05T14:00:00-8:00 .

:meetingDuration
      a       :DurationDescription ;
      :minutes 45 .
</PRE>
<P>The telecon and the meeting are defined as intervals. 
<CODE>hasBeginning</CODE> is used for specifying the start times of the 
meetings. The datetimes are specified using <CODE>inXSDDateTime</CODE>. The 
duration of the meeting is specified using the duration description class.</P>
</section>


<HR>

<section class="appendix" id="summary"><h2>Summary of Classes and Properties in the Time Ontology</h2><A name=changes></A>
<section id="changes"><h3>Classes (subclass relations)</h3>
<UL>
  <LI>TemporalEntity
  <UL>
    <LI>Instant</li>
    <LI>Interval
    <UL>
      <LI>ProperInterval
      <UL>
        <LI>DateTimeInterval</li></UL></LI></UL></LI></UL>
  <LI>DurationDescription</li>
  <li>DateTimeDescription</li>
  <LI>TemporalUnit </li>
  <li>DayOfWeek</LI></UL>
</section>
<section id="properties"><h3>Properties</h3>
<TABLE id="table1">
  <TBODY>
  <TR>
    <th>Property Name</th>
    <th>Domain</th>
    <th>Range</th>
  </tr>
  <TR>
    <TD>before</TD>
    <TD>TemporalEntity</TD>
    <TD>TemporalEntity</TD></TR>
  <TR>
    <TD>after</TD>
    <TD>TemporalEntity</TD>
    <TD>TemporalEntity</td>
  </tr>
  <TR>
    <TD>hasBeginning</TD>
    <TD>TemporalEntity</TD>
    <TD>Instant</td</tr>
  <TR>
    <TD>hasEnd</TD>
    <TD>TemporalEntity</TD>
    <TD>Instant</TD></TR>
  <TR>
    <TD>inside</TD>
    <TD>Interval</TD>
    <TD>Instant</TD></TR>
  <TR>
    <TD>intervalEquals</TD>
    <TD>ProperInterval</TD>
    <TD>ProperInterval</TD></TR>
  <TR>
    <TD>intervalBefore</TD>
    <TD>ProperInterval</TD>
    <TD>ProperInterval</TD></TR>
  <TR>
    <TD>intervalMeets</TD>
    <TD>ProperInterval</TD>
    <TD>ProperInterval</TD></TR>
  <TR>
    <TD>intervalOverlaps</TD>
    <TD>ProperInterval</TD>
    <TD>ProperInterval</TD></TR>
  <TR>
    <TD>intervalStarts</TD>
    <TD>ProperInterval</TD>
    <TD>ProperInterval</TD></TR>
  <TR>
    <TD>intervalDuring</TD>
    <TD>ProperInterval</TD>
    <TD>ProperInterval</TD></TR>
  <TR>
    <TD>intervalFinishes</TD>
    <TD>ProperInterval</TD>
    <TD>ProperInterval</TD></TR>
  <TR>
    <TD>intervalAfter</TD>
    <TD>ProperInterval</TD>
    <TD>ProperInterval</TD></TR>
  <TR>
    <TD>intervalMetBy</TD>
    <TD>ProperInterval</TD>
    <TD>ProperInterval</TD></TR>
  <TR>
    <TD>intervalOverlappedBy</TD>
    <TD>ProperInterval</TD>
    <TD>ProperInterval</TD></TR>
  <TR>
    <TD>intervalStartedBy</TD>
    <TD>ProperInterval</TD>
    <TD>ProperInterval</TD></TR>
  <TR>
    <TD>intervalContains</TD>
    <TD>ProperInterval</TD>
    <TD>ProperInterval</TD></TR>
  <TR>
    <TD>intervalFinishedBy</TD>
    <TD>ProperInterval</TD>
    <TD>ProperInterval</TD></TR>
  <TR>
    <TD>years</TD>
    <TD>DurationDescription</TD>
    <TD>xsd:decimal</TD></TR>
  <TR>
    <TD>months</TD>
    <TD>DurationDescription</TD>
    <TD>xsd:decimal</TD></TR>
  <TR>
    <TD>weeks</TD>
    <TD>DurationDescription</TD>
    <TD>xsd:decimal</TD></TR>
  <TR>
    <TD>days</TD>
    <TD>DurationDescription</TD>
    <TD>xsd:decimal</TD></TR>
  <TR>
    <TD>hours</TD>
    <TD>DurationDescription</TD>
    <TD>xsd:decimal</TD></TR>
  <TR>
    <TD>minutes</TD>
    <TD>DurationDescription</TD>
    <TD>xsd:decimal</TD></TR>
  <TR>
    <TD>seconds</TD>
    <TD>DurationDescription</TD>
    <TD>xsd:decimal</TD></TR>
  <TR>
    <TD>hasDurationDescription</TD>
    <TD>TemporalEntity</TD>
    <TD>DurationDescription</TD></TR>
  <TR>
    <TD>unitType</TD>
    <TD>DateTimeDescription</TD>
    <TD>TemporalUnit</TD></TR>
  <TR>
    <TD>year</TD>
    <TD>DateTimeDescription</TD>
    <TD>xsd:gYear</TD></TR>
  <TR>
    <TD>month</TD>
    <TD>DateTimeDescription</TD>
    <TD>xsd:gMonth</TD></TR>
  <TR>
    <TD>week</TD>
    <TD>DateTimeDescription</TD>
    <TD>xsd:nonNegativeInteger</TD></TR>
  <TR>
    <TD>day</TD>
    <TD>DateTimeDescription</TD>
    <TD>xsd:gDay</TD></TR>
  <TR>
    <TD>dayOfWeek</TD>
    <TD>DateTimeDescription</TD>
    <TD>DayOfWeek</TD></TR>
  <TR>
    <TD>dayOfYear</TD>
    <TD>DateTimeDescription</TD>
    <TD>xsd:nonNegativeInteger</TD></TR>
  <TR>
    <TD>hour</TD>
    <TD>DateTimeDescription</TD>
    <TD>xsd:nonNegativeInteger</TD></TR>
  <TR>
    <TD>minute</TD>
    <TD>DateTimeDescription</TD>
    <TD>xsd:nonNegativeInteger</TD></TR>
  <TR>
    <TD>second</TD>
    <TD>DateTimeDescription</TD>
    <TD>xsd:decimal</TD></TR>
  <TR>
    <TD>timeZone</TD>
    <TD>DateTimeDescription</TD>
    <TD>tzont;TimeZone</TD></TR>
  <TR>
    <TD>inDateTime</TD>
    <TD>Instant</TD>
    <TD>DateTimeDescription</TD></TR>
  <TR>
    <TD>inXSDDateTime</TD>
    <TD>Instant</TD>
    <TD>xsd:dateTime</TD></TR>
  <TR>
    <TD>hasDateTimeDescription</TD>
    <TD>DateTimeInterval</TD>
    <TD>DateTimeDescription</TD></TR>
  <TR>
    <TD>xsdDateTime</TD>
    <TD>DateTimeInterval</TD>
    <TD>xsd:dateTime</TD></TR></TBODY></TABLE>
</section>
</section>

<section class="appendix" id="timezone"><h2>Time Zone Resource in OWL</h2>
<p id="timezones-owl">We have developed a time zone resource [<a href="#ref-15">15</a>] in 
OWL for not only the US but also the entire world, including three parts: the 
time zone ontology file [<A 
href="#ref-16">16</A>], 
the US time zone instance file [<A 
href="#ref-17">17</A>], 
and the world time zone instance file [<A 
href="#ref-18">18</A>]. 
</P>
<P>The time zone ontology links a preliminary geographic ontology with a time 
ontology. It defines the vocabulary about regions, political regions (countries, 
states, counties, reservations, and cities), time zones, daylight saving 
policies, and the relationships between these concepts. Its instances also link 
to other existing data on the Web, such as FIPS 55 county instances [<A 
href="#ref-19">19</A>], 
and ISO country instances [<a href="#ref-20">20</a>].</P>
<P>It can handle all the usual time zone and daylight savings cases. For 
example, Los Angles uses PST, the time offset from Coordinated Universal Time 
(UTC) is -8 hours, and it observed daylight savings from April 2 to October 29 
in 2006. But it handles unusual cases as well. For example, in Idaho the 
northern part is in the Pacific zone, the southern part in the Mountain. The 
city of West Wendover, Nevada is in the Mountain time zone, while the rest of 
Nevada is in the Pacific. </P>
<section id="examples1"><h3>Use case examples</h3>
<P id="codesyntax0">Suppose someone has a telecon scheduled for 6:00pm EST on 
November 5, 2006. You would like to make an appointment with him for 2:00pm PST 
on the same day, and expect the meeting to last 45 minutes. Will there be an 
overlap? In order to specify the facts about the telecon and the meeting and 
reason about the relation between them, a time zone ontology would be necessary 
to help a time ontology (e.g. OWL-Time) to resolve the time difference between 
EST and PST. [<A 
href="#ref-anti-use">Anticipated 
Use</A>] will be described in detail in a later section.</P>
</section>

<section id="ontology"><h3>Time Zone Ontology</h3>
<P>We take <CODE>PoliticalRegion</CODE> to be a subclass of <CODE>Region</CODE> 
with the following properties: 
<UL>
  <LI><B>name</B>: at most one string. </LI></UL>
<UL>
  <LI><B>hasParentRegion</B>: the parent political region. </LI></UL>
<UL>
  <LI><B>hasTimeZone</B>: at most three time zones. </LI></UL>
<UL>
  <LI><B>observesDaylightSavingsTime</B>: true if the region goes on daylight 
  savings time, false otherwise. </LI></UL>
<UL>
  <LI><B>hasDaylightSavingsPolicy</B>: the daylight saving policy that the 
  region uses. </LI></UL>
<UL>
  <LI><B>exceptionalRegion</B>: exceptional sub-political-regions that have 
  different time zones and/or daylight saving time policies (e.g. West Wendover, 
  Nevada). </LI></UL>
<UL>
  <LI><B>timeZonePart</B>: sub-non-political-regions that have different time 
  zones and/or daylight saving time policies (e.g. two different time zone parts 
  in Idaho County in Idaho State). </LI></UL>
<P>This can be defined in OWL as:</P><PRE>:PoliticalRegion
      a       owl:Class ;
      rdfs:subClassOf :Region ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :name
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :hasParentRegion
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 3 ;
                owl:onProperty :hasTimeZone
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :observesDaylightSavingsTime
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :hasDaylightSavingsPolicy
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:minCardinality 0 ;
                owl:onProperty :exceptionalRegion
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:minCardinality 0 ;
                owl:onProperty :timeZonePart
              ] .</PRE>
<P>Countries, states, counties, cities, and reservations are all subclass of 
political regions with different range types for the 
<CODE>hasParentRegion</CODE> property.<BR><BR>For example, <CODE>Country</CODE> 
and <CODE>State</CODE> can be defined in OWL as:</P><PRE>:Country
      a       owl:Class ;
      rdfs:subClassOf :PoliticalRegion .</PRE><PRE>:State
      a       owl:Class ;
      rdfs:subClassOf :PoliticalRegion ;
      owl:subClassOf
              [ a       owl:Restriction ;
               owl:onProperty :hasParentRegion ; 
               owl:allValuesFrom :Country                 
              ] .</PRE>Time zones have two properties: 
<UL>
  <LI><B>name</B>: at most one string. </LI></UL>
<UL>
  <LI><B>GMToffset</B>: an XML Schema duration between -12 and +14 
hours.</LI></UL>
<P>This can be defined in OWL as:</P><PRE>:TimeZone
      a       owl:Class ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :name
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :GMToffset
              ] .</PRE>
<P>We assume default reasoning is used for this ontology. When a political 
region lacks one of its properties, we will use the one from its parent region. 
Thus all political sub-regions of the United States get their 
<CODE>DaylightSavingsPolicy</CODE> values from that of the United States, 
provided their <CODE>observesDaylightSavingsTime</CODE> property is true. All 
counties in California get their <CODE>hasTimeZone</CODE> values from 
California, whereas the <CODE>hasTimeZone</CODE> value is specified for each 
county in Kentucky and not for the state as a whole, since it is split between 
the Eastern and Central time zones. When most of a region is in one time zone, 
and only some exceptional sub-regions are in different time zones or have 
different daylight savings time policies, we use <CODE>exceptionalRegion</CODE> 
to point to each exceptional sub-region, e.g. West Wendover, which is in the 
Mountain time zone, is an exception in Nevada, which is otherwise in the Pacific 
time zone. <A name=ref-west-wen></A>Here is the OWL code of Nevada and West 
Wendover in the US time zone instance file [<a href="#ref-17">17</a>]:</P><PRE>:us-states:NV
      a       :State ;
      :hasParentRegion iso:US;
      :hasTimeZone :<B>PST</B> ;
      :observesDaylightSavingsTime true ;
      :<B>exceptionalRegion</B> :<B>NVWestWendoverCity</B> .

:NVWestWendoverCity
      a       :City ;
      :name "West Wendover City" ;
      :stateOf us-states:NV ;
      :hasTimeZone :<B>MST</B> ;
      owl:sameIndividualAs
              &lt;<A href="http://www.daml.org/2003/02/fips55/NV.owl#p83730">http://www.daml.org/2003/02/fips55/NV.owl#p83730</A>&gt; .</PRE>
<P>When different parts of the same county are in different time zones, the 
<CODE>hasTimeZone</CODE> is not specified for the county. Instead the 
<CODE>hasTimeZone</CODE> is specified for each part with different time zones, 
and the <CODE>timeZonePart</CODE> property is used to point to the parts from 
the county instance, e.g. the two different time zone parts in Idaho County, 
Idaho. Here is the OWL encoding of Idaho County, Idaho in our US time zone 
instance file [<a href="#ref-17">17</a>]:</P><PRE>:IDIdaho
      a       :County ;
      :name "Idaho County" ;
      :hasParentRegion
              us-states:ID ;
      :<B>timeZonePart</B>
              :<B>IDIdahoPST</B> , :<B>IDIdahoMST</B> ;
      owl:sameIndividualAs
              &lt;http://www.daml.org/2003/02/fips55/ID.owl#c049&gt; .</PRE><A 
name=ontology0></A><CODE>DaylightSavingsPolicy</CODE> has one property: 
<UL>
  <LI><B>lastUpdated</B>: the time that the daylight savings policy was updated. 
  </LI></UL>
<P><CODE>EnumeratedDaylightSavingsPolicy</CODE>, a subclass of 
<CODE>DaylightSavingsPolicy</CODE>, has the following properties:</P>
<UL>
  <LI><B>DLSstartDate</B>: the date the region goes on daylight savings time. 
  </LI></UL>
<UL>
  <LI><B>DLSendDate</B>: the date the region goes off daylight savings 
time.</LI></UL>
<P>This can be defined in OWL as:</P><PRE>:EnumeratedDaylightSavingsPolicy
      a       owl:Class ;
      rdfs:subClassOf :DaylightSavingsPolicy ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :DLSendDate
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :DLSstartDate
              ] .</PRE>
<P><CODE>DLSstartDate</CODE> and <CODE>DLSendDate</CODE> properties have the 
range of xsd:date. In the current instance 
files, different daylight saving policies were only defined for year 2006 as 
instances of <CODE>EnumeratedDaylightSavingsPolicy</CODE>, e.g. 
<CODE>USA2006DLS</CODE> for the United States, and <CODE>EU2006DLS</CODE> for 
the European Union.&nbsp;</P>
<P><A name=ref-temp-agg-eg></A>Alternatively, a temporal aggregates ontology in 
OWL-Time can be used to describe the daylight saving policies. For example, in 
the US daylight saving starts on "the first Sunday of every April", which can be 
expressed in OWL as:</P><PRE>:tseq
      a       :TemporalSeq ;
      :hasTemporalAggregateDescription
              :firstSunEveryApril .</PRE><PRE>:tseq-everyApril
      a       :TemporalSeq ;
      :hasTemporalAggregateDescription
              :everyApril .</PRE><PRE>:everyApril
      a       :TemporalAggregateDescription ;
      :hasTemporalUnit
              :unitMonth ;
      :hasithTemporalUnit 4 .

:firstSunEveryApril
      a       :TemporalAggregateDescription ;
      :hasContextTemporalSeq
              :tseq-everyApril ;
      :hasContextTemporalUnit
              :unitMonth ;
      :hasithTemporalUnit 7 ;
      :hasTemporalUnit
              :unitDay ;
      :hasPosition 1 .</PRE>
<P>This defines the desired temporal sequence <CODE>tseq</CODE> of class 
<CODE>TemporalSeq</CODE> which has a 
<CODE>hasTemporalAggregateDescription</CODE> property that points to a temporal 
aggregate description <CODE>firstSunEveryApril</CODE> that describes the 
temporal sequence. In order to describe this two-layered temporal sequence ("the 
first Sunday" of "every April"), the outside layer ("every April"), i.e. the 
context temporal sequence (<CODE>tseq-everyApril</CODE>), needs to be defined 
first. This context temporal sequence also has its own 
<CODE>hasTemporalAggregateDescription</CODE> property that points to 
<CODE>everyApril</CODE> which describes that it is the every 4th 
(<CODE>hasithTemporalUnit</CODE> of 4) month (<CODE>hasTemporalUnit</CODE> of 
<CODE>unitMonth</CODE>). The desired temporal sequence is then defined as "the 
first (<CODE>hasPosition</CODE> of 1) Sunday (<CODE>hasithTemporalUnit</CODE> of 
7 and <CODE>hasTemporalUnit</CODE> of <CODE>unitDayOfWeek</CODE>) of every April 
(<CODE>hasContextTemporalSeq</CODE> of <CODE>tseq-everyApril</CODE> and 
<CODE>hasContextTemporalUnit</CODE> of <CODE>unitMonth</CODE>)".</P>
<P>For details about the temporal aggregates ontology and its use case examples, 
please see [<a href="#ref-6">6</a>,<a href="#ref-7">7</a>].</P>

<section id="timezone-ont"><h4>OWL code for the time zone ontology </h4>
<P>[<A href="/2006/timezone">RDF/XML</A>]</P>
</section>
</section>

<section id="ref-anti-use"><h3>Anticipated Use</h3>
<P>The expected input to the ontology is a location, e.g. a city, and the output 
will be its current time offset, say -6 hours, from the Greenwich Mean Time 
(GMT).<BR><BR>The ontology would be used as follows: given an input location, we 
first find in the ontology the lowest-level political region containing this 
location, say a county, then go up along the political region hierarchy based on 
the <CODE>hasParentRegion</CODE> property to the top of the hierarchy, usually a 
country. Along the path to the top, we get all the available information from 
each node (region) in order to calculate the time offset from the GMT. The 
information includes the time zone this location is in, whether it uses Daylight 
Savings (DLS) time, and if it does, what the start and end dates are. </P>
<P>However, flexible inputs and more efficiency are supported by using the 
<CODE>exceptionalRegion</CODE> and <CODE>timeZonePart</CODE> properties, i.e. 
the location input does not have to be as detailed as the lowest-level political 
region, especially because usually only the information about what state it is 
in would be enough to calculate the time offset from the GMT for the input 
location. </P>
<P>If the input only says it's a location of a state without specifying the 
county or city it is in, then we can first go to its state and see whether we 
can find all the information we need there, i.e. time zone and daylight savings 
information. If the state doesn't have any <CODE>exceptionalRegion</CODE>’s, 
then we don't need any more inputs for this location, and can safely go up along 
the political region hierarchy to the top of the hierarchy, e.g. the country US, 
and get all the information we need along the way to calculate the time offset 
from the GMT for this location. If the state does have any 
<CODE>exceptionalRegion</CODE>’s, however, we have to check each exceptional 
region to see whether this location is in it or not, at this checking phase, 
more detailed information about this location may be needed, i.e. which 
county/city/reservation it is in. If it's in an exceptional county that further 
has <CODE>timeZonePart</CODE>’s, then even more detailed information is needed 
from the input, i.e. which time zone part the location is in within this county. 
When reaching a sub-region with no <CODE>exceptionalRegion</CODE>’s or 
<CODE>timeZonePart</CODE>’s, we know for sure that no more input location 
information is needed and it's safe to go up along the political region 
hierarchy to the top, and get all the information we need to calculate the time 
offset from the GMT for this location. <BR><BR>For example, suppose the input 
location is a location in West Wendover, Nevada, but at first we only know it's 
in Nevada (please see the OWL code [<A 
href="#ref-west-wen">in the 
previous section</A>]). In the ontology, we first find Nevada state, from which 
we see one exceptional region pointing to West Wendover City, then we ask for 
further input location information: which city is this location in? Say we get 
West Wendover City. Since it matches the exceptional region, we then go to the 
West Wendover City instance to get its time zone information, which is the 
Mountain time zone. Since there is no <CODE>exceptionalRegion</CODE>’s or 
<CODE>timeZonePart</CODE>’s in the West Wendover City instance, it's now safe 
for us to go up along the hierarchy to the top, the United States. Along the 
path, at Nevada State we learn this location uses DLS time, then at its parent 
region, the US, we learn the DLS policy used is USA2006DLS which specifies the 
start date of the DLS in 2006 is 04/02/2006 and the end date is 10/29/2006. 
Based on our current time, e.g. 1:50pm on 09/06/2006, we know the current time 
offset from the GMT at this location is -7 hours. </P>
</section>
</section>


<HR>

<A name=examples2></A>
<section id="references"><h2>References</h2>
<P><A name=ref-1></A>[1] Allen, J. F. 1984. Towards a general theory of action 
and time. <I>Artificial Intelligence </I>23, pp. 123-154.<BR><BR><A 
name=ref-2></A>[2] Allen, J. F. and Ferguson, G. 1997. Actions and events in 
interval temporal logic. In <I>Spatial and Temporal Reasoning</I>. O. Stock, 
ed., Kluwer, Dordrecht, Netherlands, 205-245.</P>
<P><A 
name=ref-3></A>[3] Dawson, F. and Stenerson, D. 1998. Internet Calendaring and Scheduling Core Object 
Specification (iCalendar), RFC2445. <A 
href="http://www.ietf.org/rfc/rfc2445.txt">http://www.ietf.org/rfc/rfc2445.txt</A></P>
<P><A name=ref-4></A>[4] 
Hobbs, J. R. and Pan, F. 2004. An Ontology of Time for the Semantic Web. <I>ACM 
Transactions on Asian Language Processing (TALIP): Special issue on Temporal 
Information Processing</I>, Vol. 3, No. 1, March 2004, pp. 66-85. </P>
<P><A 
name=ref-5></A>[5] Pan, F and Hobbs, J. R. 2004. Time in OWL-S. In 
<I>Proceedings of the AAAI Spring Symposium on Semantic Web Services</I>, 
Stanford University, CA, pp. 29-36.</P>
<P><A name=ref-6></A>[6] Pan, F and Hobbs, J. R. 2005. Temporal Aggregates in OWL-Time. In <i>
Proceedings of the 18th International Florida Artificial Intelligence Research 
Society Conference (FLAIRS)</i>, Clearwater Beach, Florida, pp. 560-565, AAAI Press.
<P><A name=ref-7></A>
[7] Pan, F. 2005. A Temporal Aggregates Ontology in OWL for the Semantic Web. In
<i>Proceedings of the AAAI Fall Symposium on Agents and the Semantic Web</i>, 
Arlington, Virginia, pp. 30-37.&nbsp;</P>
<P><A 
name=ref-8></A>[8] OWL code of the time ontology. <A 
href="http://www.w3.org/2006/time">http://www.w3.org/2006/time</A><BR><BR><A 
name=ref-9></A>[9] OWL code of the entry sub-ontology of time. <A 
href="http://www.w3.org/2006/time-entry">http://www.w3.org/2006/time-entry</A></P>
<P><A name=ref-10></A>[10] OWL-Time Homepage: <A 
href="http://www.isi.edu/~pan/OWL-Time.html">http://www.isi.edu/~pan/OWL-Time.html</A><BR><BR>
<A 
name=ref-11></A>[11] OWL-S homepage. <A 
href="http://www.daml.org/services/owl-s/">http://www.daml.org/services/owl-s/</A></P>
<P><A 
name=ref-12></A>[12] OWL-S 0.9 release. <A 
href="http://www.daml.org/services/daml-s/0.9/">http://www.daml.org/services/daml-s/0.9/</A></P>
<P><A 
name=ref-13></A>[13] OWL-S 1.1 release. <A 
href="http://www.daml.org/services/owl-s/1.1/">http://www.daml.org/services/owl-s/1.1/</A><BR><BR><A 
name=ref-14></A>[14] The process file of the OWL-S 0.9 release. <A 
href="http://www.daml.org/services/owl-s/0.9/Process.owl">http://www.daml.org/services/owl-s/0.9/Process.owl</A></P>
<P><A 
name=ref-15></A>[15] The homepage of the time zone resource in OWL. <A 
href="http://www.isi.edu/~pan/timezonehomepage.html">http://www.isi.edu/~pan/timezonehomepage.html</A><BR><BR><A 
name=ref-16></A>[16] The time zone ontology file. <A 
href="http://www.w3.org/2006/timezone">http://www.w3.org/2006/timezone</A><BR><BR><A 
name=ref-17></A>[17] The US time zone instance file.<B> </B><A 
href="http://www.w3.org/2006/timezone-us">http://www.w3.org/2006/timezone-us</A><BR><BR><A 
name=ref-18></A>[18] The world time zone instance file. <A 
href="http://www.w3.org/2006/timezone-world">http://www.w3.org/2006/timezone-world</A><BR><BR><A 
name=ref-19></A>[19] FIPS 55 County instance file. <A 
href="http://www.daml.org/2003/02/fips55/">http://www.daml.org/2003/02/fips55/</A><BR><BR><A 
name=ref-20></A>[20] ISO Country instance file. <A 
href="http://www.daml.org/2001/09/countries/iso">http://www.daml.org/2001/09/countries/iso</A></P>
</section>
<HR>


<A name=examples3></A>
<section id="ack"><h2>Acknowledgements</h2>
<p>The editors would like to thank Deborah McGuinness, Chris Welty, and the 
reviewers of the earlier versions of the doucment, i.e., Jeremy Carroll, John 
McClure, Libby Miller, and Guus Schreiber, for their very helpful feedbacks and 
comments to the document.</p>
</section>

</BODY></HTML>
