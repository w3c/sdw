<!DOCTYPE html>
<html>
  <head>
    <meta  content="text/html; charset=utf-8"  http-equiv="content-type">
    <meta  content="width=device-width,initial-scale=1"  name="viewport">
    <title>Time Ontology in OWL</title>
    <script  class="remove"  src="http://www.w3.org/Tools/respec/respec-w3c-common"></script>
    <script  class="remove"  src="config.js"></script>
    <style  type="text/css">

/* Table styles, March 2016 */

table {border-collapse:collapse}
th, td {
  border:thin solid black;
  padding: 0.3em;
}

.inlineCode {
	FONT-FAMILY: "courier new"; BACKGROUND-COLOR: #ddf
}
PRE.code {
	BORDER-RIGHT: #999999 1pt solid; PADDING-RIGHT: 0.5em; BORDER-TOP: #999999 1pt solid; PADDING-LEFT: 0.5em; PADDING-BOTTOM: 0.5em; BORDER-LEFT: #999999 1pt solid; PADDING-TOP: 0.5em; BORDER-BOTTOM: #999999 1pt solid; FONT-FAMILY: "courier new"; BACKGROUND-COLOR: #eef
}
PRE.code2 {
	BORDER-RIGHT: #999999 1pt solid; PADDING-RIGHT: 0.5em; BORDER-TOP: #999999 1pt solid; PADDING-LEFT: 0.5em; PADDING-BOTTOM: 0.5em; BORDER-LEFT: #999999 1pt solid; PADDING-TOP: 0.5em; BORDER-BOTTOM: #999999 1pt solid; FONT-FAMILY: "courier new"; BACKGROUND-COLOR: #ffa
}
.ednote {
	FONT-STYLE: italic
}
PRE.clientmsg {
	BORDER-RIGHT: #999 1px solid; PADDING-RIGHT: 2px; BORDER-TOP: #999 1px solid; PADDING-LEFT: 2px; BACKGROUND: #eee; PADDING-BOTTOM: 2px; MARGIN: 0px; BORDER-LEFT: #999 1px solid; PADDING-TOP: 2px; BORDER-BOTTOM: #999 1px solid
}
PRE.servermsg {
	BORDER-RIGHT: #999 1px solid; PADDING-RIGHT: 2px; BORDER-TOP: #999 1px solid; PADDING-LEFT: 2px; BACKGROUND: #eee; PADDING-BOTTOM: 2px; MARGIN: 5px 0px 0px; BORDER-LEFT: #999 1px solid; PADDING-TOP: 2px; BORDER-BOTTOM: #999 1px solid; TEXT-ALIGN: left
}
P.msg {
	PADDING-RIGHT: 0px; PADDING-LEFT: 0px; PADDING-BOTTOM: 0px; MARGIN: 0px; PADDING-TOP: 0px; TEXT-ALIGN: center
}
DIV.interaction {
	BORDER-RIGHT: #999 1px solid; PADDING-RIGHT: 5px; BORDER-TOP: #999 1px solid; PADDING-LEFT: 5px; PADDING-BOTTOM: 5px; BORDER-LEFT: #999 1px solid; PADDING-TOP: 5px; BORDER-BOTTOM: #999 1px solid
}
DIV.interaction H4 {
	MARGIN: 0px 0px 10px
}
DIV.interaction P {
	MARGIN: 0px
}
DIV.test {
	BORDER-RIGHT: #999 1px solid; PADDING-RIGHT: 5px; BORDER-TOP: #999 1px solid; PADDING-LEFT: 5px; PADDING-BOTTOM: 5px; BORDER-LEFT: #999 1px solid; PADDING-TOP: 5px; BORDER-BOTTOM: #999 1px solid
}
DIV.test H4 {
	MARGIN: 0px 0px 10px
}
</style> </head>
  <body>
    <section  id="abstract">
      <p>This document presents an ontology of temporal concepts, OWL-Time, for
        describing the temporal properties of resources described in Web pages.
        The ontology provides a vocabulary for expressing facts about
        topological relations among instants and intervals, together with
        information about durations, and about temporal position including
        date-time information. <span  style="font-style: italic;">We also
          demonstrate in detail, using the Congo.com and Bravo Air examples from
          OWL-S [<a  href="#ref-11">11</a>], how this time ontology can be used
          to support OWL-S, including use cases for defining input parameters
          and (conditional) output parameters. A use case for meeting scheduling
          is also shown. In the appendix we also describe a time zone resource
          in OWL we developed for not only the US but also the entire world,
          including the time zone ontology, the US time zone instances, and the
          world time zone instances</span>.</p>
    </section>
    <section  id="sotd">
      <p>This version of OWL-Time was developed in the Spatial Data on the Web
        Working Group (a joint activity involving W3C and the Open Geospatial
        Consortium). It is based on the earlier draft by Hobbs and Pan, [<a  href="#OWL-Time-2006">21</a>],
        which in turn originated as DAML-Time [<a  href="#ref-4">4</a>,<a  href="#ref-10">10</a>]</p>
    </section>
    <section  id="general">
      <h2>General issues</h2>
      <p>Temporal information is so common that it’s hard to find a real world
        Web service without it. For example, whenever you place an online order,
        the order date is always part of your order. When you reserve a car at a
        car rental site, you have to specify the dates you need it. In response
        to this need, a temporal ontology, OWL-Time (formerly DAML-Time), has
        been developed for describing the temporal content of Web pages and the
        temporal properties of Web services. Its development is being informed
        by temporal ontologies developed at a number of sites and is intended to
        capture the essential features of all of them and make them and their
        associated resources easily available to a large group of Web developers
        and users.&nbsp;Although it can be used independently, we have made sure
        it works well with OWL-S. Advantages of OWL-Time over XML Schema
        datatype <code>duration</code> and <code>dateTime</code> will be
        discussed.</p>
      <p>This document only presents the OWL encodings of the ontology. For a
        first-order logic axiomatization of the ontology, see [<a  href="#ref-4">4</a>,<a
           href="#ref-10">10</a>]. In an extension of the time ontology [<a  href="#ref-5">5</a>,<a
           href="#ref-9">9</a>], we also allow temporal predicates to apply
        directly to events, should the user wish, but here we restrict our
        treatment to temporal entities. </p>
    </section>
    <section  id="examples">
      <h2>Use case examples</h2>
      <p>A simple use case example: "Suppose someone has a telecon scheduled for
        6:00pm EST on November 5, 2006. You would like to make an appointment
        with him for 2:00pm PST on the same day, and expect the meeting to last
        45 minutes.&nbsp; Will there be an overlap?" In this use case we can
        specify the facts about the telecon and the meeting using our ontology
        in OWL that will allow a temporal reasoner to determine whether there is
        a conflict. See [<a  href="#scheduling">A Use Case for Scheduling</a>]
        section for details.</p>
      <p>More examples: "Someone who does a Web search trying to find a place to
        buy a book needed before next Tuesday may or may not be able to use an
        online bookstore that promises delivery within five business days." </p>
      <p>"Someone doing a genealogical search may want to specify that the
        birthdate of a person is between 15 and 45 years before a known marriage
        date."</p>
      <p>More use case examples will be described in detail in [<a  href="#ref-time-in-owl-s">Use
          Cases for Web Services</a>] section below. </p>
    </section>
    <section  id="syntax">
      <h2>Syntax for code</h2>
      <p>In keeping with SWBP policy, the code within the body of the note is in
        N3. Most of the code was generated by Protégé from the original OWL code
        in RDF/XML. Details in alternative syntaxes are given by links.</p>
    </section>
    <hr>
    <section  id="relations">
      <h2>Topological Temporal Relations</h2>
      <p>There are two subclasses of <code>TemporalEntity</code>: <code>Instant</code>
        and <code>Interval</code>, and they are the only two subclasses of <code>TemporalEntity</code>:</p>
      <pre>:Instant
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; owl:Class ;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rdfs:subClassOf :TemporalEntity .</pre>
      <pre>:Interval
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; owl:Class ;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rdfs:subClassOf :TemporalEntity .</pre>
      <pre>:TemporalEntity
      a       owl:Class ;
      rdfs:subClassOf :TemporalThing ;
      owl:equivalentClass
              [ a       owl:Class ;
                owl:unionOf (:Instant :Interval)
              ] .</pre>
      <p>Intervals are, intuitively, things with extent and instants are,
        intuitively, point-like in that they have no interior points. It is
        generally safe to think of an instant as an interval with zero length,
        where the beginning and end are the same.</p>
      <p><code>hasBeginning</code> and <code>hasEnd</code> are relations
        between instants and temporal entities, and the beginnings and ends of
        temporal entities, if they exist, are unique. In some approach to
        infinite intervals, a positively infinite interval has no end, and a
        negatively infinite interval has no beginning. Hence, we use the
        relations <code>hasBeginning</code> and <code>hasEnd</code> in the
        ontology, rather than defining functions <code>beginningOf</code> and <code>endOf</code>,
        since the functions would not be total. <code>hasBeginning</code>, for
        example, can be specified as:</p>
      <pre>:hasBeginning
      a       owl:ObjectProperty ;
      rdfs:domain :TemporalEntity ;
      rdfs:range :Instant .</pre>
      <p><code>inside</code> is a relation between an instant and an interval,
        and it is not intended to include beginnings and ends of
        intervals.&nbsp;There is a <code>before</code> relation on temporal
        entities, which gives directionality to time. If a temporal entity <code>T<sub>1</sub></code>
        is before another temporal entity <code>T<sub>2</sub></code>, then the
        end of <code>T<sub>1</sub></code> is before the beginning of <code>T<sub>2</sub></code>.
        Thus, before can be considered to be basic to instants and derived for
        intervals.&nbsp;</p>
      <p>Allen and Furgerson [<a  href="#ref-1">1</a>,<a  href="#ref-2">2</a>]
        have developed a calculus of binary relations on intervals (e.g., meets,
        overlaps) for representing qualitative temporal information and address
        the problem of reasoning about such information. The relations between
        intervals defined in their calculus can be defined in a relatively
        straightforward fashion in terms of <code>before</code> and identity on
        the beginning and end points. The standard interval calculus assumes all
        intervals are proper, and we do that here too. Proper intervals are ones
        whose beginning and end are different. It can be specified as:</p>
      <pre>:ProperInterval
      a       owl:Class ;
      rdfs:subClassOf :Interval ;
      owl:disjointWith :Instant .</pre>
      <p>OWL-Time provides the interval relations: <code>intervalEquals</code>,
        <code>intervalBefore</code>, <code>intervalMeets</code>, <code>intervalOverlaps</code>,
        <code>intervalStarts</code>, <code>intervalDuring</code>, <code>intervalFinishes</code>,
        and their reverse interval relations: <code>intervalAfter</code>, <code>intervalMetBy</code>,
        <code>intervalOverlappedBy</code>, <code>intervalStartedBy</code>, <code>intervalContains</code>,
        <code>intervalFinishedBy</code>. For example, the specification of <code>intervalEquals</code>
        is:</p>
      <pre>:<code>interval</code>Equals
      a       owl:ObjectProperty ;
      rdfs:domain :ProperInterval ;
      rdfs:range :ProperInterval .</pre>
    </section>
    <section  id="duration">
      <h2>Duration Description</h2>
      <p>The duration of an interval (or temporal sequence) can have many
        different descriptions. An interval can be 1 day 2 hours, or 26 hours,
        or 1560 minutes, and so on. It is useful to be able to talk about these
        descriptions in a convenient way as independent objects, and to talk
        about their equivalences. We do this first in terms of a predicate
        called <code>durationOf</code> that takes eight arguments, one for a
        temporal thing, and one each for years, months, weeks, days, hours,
        minutes, and seconds. Then we will define a specific kind of individual
        called a "duration description", together with a number of functions
        relating the duration description to the values of each of the eight
        arguments. Thereby we convert the 8-ary predicate <code>durationOf</code>
        into eight binary relations that are more convenient for description
        logic-based markup languages, such as OWL:</p>
      <pre>:DurationDescription
      a       owl:Class ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :seconds
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :minutes
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :hours
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :days
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :weeks
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :months
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :years
              ] .</pre>
      <p>An interval can have multiple duration descriptions (e.g., 2 days, 48
        hours), but can only have one duration. </p>
      <p>We use two different sets of properties for <code>DateTimeDescription</code>
        and <code>DurationDescription</code>, because their ranges are
        different. For example, <code>year</code> (in <code>DateTimeDescription</code>)
        has a range of <code>xsd:gYear</code>, while <code>years</code> (in <code>DurationDescription</code>)
        has a range of <code>xsd:decimal</code> so that you can say duration of
        2.5 years.</p>
      <p>iCalendar [<a  href="#ref-3">3</a>] is a widely supported standard for
        personal data interchange. It provides the definition of a common format
        for openly exchanging calendaring and scheduling information across the
        Internet. The representation of temporal concepts in this time ontology
        can be straightforwardly mapped to iCalendar. For example, duration of
        15 days, 5 hours and 20 seconds is represented in iCalendar as
        P15DT5H0M20S, which can be represented in the time ontology as:</p>
      <pre>:duration
      a       :DurationDescription ;
      :seconds 20 ;
      :hours 5 ;
      :days 15 .
</pre>
      <p><a  name="ref-duration"></a>The relation <code>hasDurationDescription</code>
        is used to specify a duration description for a temporal entity:</p>
      <pre>:hasDurationDescription
      a       owl:ObjectProperty ;
      rdfs:domain :TemporalEntity ;
      rdfs:range :DurationDescription .</pre>
      <p>Other duration concepts can be straightforwardly defined. For example,
        duration "Year" can be defined as a subclass of "DurationDescription"
        with the restrictions that the "years" property is required (with
        "cardinality" of 1) and all other properties (e.g., "hours", "months")
        should not be present (with "cardinality" of 0):</p>
      <pre>:Year
      a       owl:Class ;
      rdfs:subClassOf :DurationDescription ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:cardinality 1 ;
                owl:onProperty :years
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:cardinality 0 ;
                owl:onProperty :months
              ] ;
      ...

      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:cardinality 0 ;
                owl:onProperty :seconds
              ] .
</pre>Here we use "cardinality = 0" instead of restricting the values of days,
      etc. to 0. The reason is that using "cardinality = 0" means all those
      properties/fields (days, etc.) should not be specified (i.e., the
      granularity is "year"), while restricting all those values to 0 means they
      all have a fixed value of 0 (i.e., x years 0 months 0 days ...) and the
      granularity is actually "second", which is not the correct semantics of
      "year".
      <p>It's worth pointing out that there is a distinction between a year as a
        duration and a calendar year. The year from December 22, 2006 to
        December 21, 2007 is the former but not the latter.</p>
    </section>
    <section  id="timezones">
      <h2>Time Zones</h2>
      <p>What hour of the day an instant is in is relative to the time zone.
        This is also true of minutes, since there are regions in the world,
        e.g., central Australia, where the hours are not aligned with UTC hours,
        but are, e.g., offset half an hour. Seconds are not relative to the time
        zone.</p>
      <p>Days, weeks, months and years are also relative to the time zone,
        since, e.g., 2006 began in the Eastern Standard time zone three hours
        before it began in the Pacific Standard time zone. Thus, predications
        about all datetime intervals except seconds are relative to a time zone.
      </p>
      <p>We have been referring to time zones, but in fact it is more convenient
        to work in terms of what we might call the "time standard" that is used
        in a time zone. That is, it is better to work with the Pacific Standard
        Time (PST) as a legal entity than with the PST zone as a geographical
        region. A time standard is a way of computing the time, relative to a
        world-wide system of computing time. For each time standard, there is a
        zone, or geographical region, and a time of the year in which it is used
        for describing local times. Where and when a time standard is used have
        to be axiomatized, and this involves interrelating a time ontology and a
        geographical ontology. These relations can be quite complex. Only the
        entities like PST and EDT, the time standards, are part of the time
        ontology.</p>
      <p>If we were to conflate time zones (i.e., geographical regions) and time
        standards, it would likely result in problems in several situations. For
        example, the Eastern Standard zone and the Eastern Daylight zone are not
        identical, since most of Indiana was on Eastern Standard time all year.
        The state of Arizona and the Navajo Indian Reservation, two overlapping
        geopolitical regions, have different time standards during the daylight
        saving times -- one is Pacific and the other is Mountain.</p>
      <p>Time standards that seem equivalent, like Eastern Standard and Central
        Daylight, should be thought of as separate entities. Whereas they
        function the same in the time ontology, they do not function the same in
        the ontology that articulates time and geography. For example, it would
        be false to say those parts of Indiana shifted in April from Eastern
        Standard to Central Daylight time.</p>
      <p>See [<a  href="#timezone">Appendix B</a>] for the details about a time
        zone resource we developed in OWL. </p>
    </section>
    <section  id="calclock"  <h2="">DateTime Description
      <p>A datetime description has the following properties/fields: <code>unitType</code>,
        <code>year</code>, <code>month</code>, <code>week</code>, <code>day</code>,
        <code>dayOfWeek</code>, <code>dayOfYear</code>, <code>hour</code>, <code>minute</code>,
        <code>second</code>, and <code>timeZone</code>. The property <code>unitType</code>
        specifies the temporal unit type of the datetime description, and its
        domain is <code>TemporalUnit</code>:</p>
      <pre>:TemporalUnit
      a       owl:Class ;
      owl:equivalentClass
              [ a       owl:Class ;
                owl:oneOf (:unitSecond :unitMinute :unitHour :unitDay :unitWeek :unitMonth :unitYear)
              ] .
</pre>
      <p>For example, the temporal unit type of 10:30 is minute (<code>unitMinute</code>),
        and the temporal unit type of March 20, 2006 is day (<code>unitDay</code>).
        The unit type is required. With a given temporal unit type, all the
        fields/properties for smaller units will be ignored. For instance, if
        the temporal unit type is day (<code>unitDay</code>), the values of the
        field/property hour, minute, and second, if present, will be ignored.
        Since datetime description is for describing datetime intervals, we
        defined a property, called <code>hasDateTimeDescription</code> with <code>DateTimeDescription</code>
        as the range, for datetime intervals. To represent "March 12 in 2006",
        for example, using datetime description, we need an instance of <code>DateTimeDescription</code>
        that has values only for <code>unitType</code>(<code>unitDay</code>), <code>year</code>(2006),
        <code>month</code>(3), and <code>day</code>(12). <code>DateTimeDescription</code>
        and <code>hasDateTimeDescription</code> are defined in OWL as:</p>
      <pre>:DateTimeDescription
      a       owl:Class ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:cardinality 1 ;
                owl:onProperty :unitType
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :second
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :minute
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :hour
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :day
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :dayOfWeek
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :dayOfYear
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :week
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :month
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :year
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :timeZone
              ] .
              
:hasDateTimeDescription
      a       owl:ObjectProperty ;
      rdfs:domain :DateTimeInterval ;
      rdfs:range :DateTimeDescription .
</pre>
      <p><code>DateTimeInterval</code> is a subclass of <code>ProperInterval</code>.
        Any <code>TemporalEntity</code> has a duration, but only <code>DateTimeInterval</code>
        can have <code>DateTimeDescription</code> (e.g., May 8 has a <code>DateTimeDescription</code>,
        but the interval from 1:30pm, May 8, to 1:30pm, May 9, does not. Both
        have a duration of a day. A <code>DateTimeDescription</code> is always
        a description of an interval (<code>DateTimeInterval</code>), not an
        instant, which can be described by&nbsp;<code>inDateTime</code> and <code>inXSDDateTime</code>,
        as described later in the section. </p>
      <p>The domain of the property <code>dayOfWeek</code> is the class <code>DayOfWeek</code>:</p>
      <pre>:DayOfWeek
      a       owl:Class ;
      owl:equivalentClass
              [ a       owl:Class ;
                owl:oneOf (:Sunday :Monday :Tuesday :Wednesday :Thursday :Friday :Saturday)
              ] .
</pre>
      <p><a  name="calclock"></a>Other datetime concepts can be
        straightforwardly defined. For example, "January" can be defined as a a
        subclass of <code>DateTimeDescription</code> with the restrictions that
        the <code>unitType</code> property has <code>allValuesFrom</code>
        unitMonth and property <code>month</code> <code>hasValue</code> of 1:</p>
      <pre>:January
      a       owl:Class ;
      rdfs:subClassOf :DateTimeDescription ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:onProperty :unitType
                owl:hasValue :unitMonth
              ] ;
     rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:onProperty :month
                owl:hasValue --01 ;
              ] .
</pre>
      <p>In order to specify that an instant is in a datetime interval, an <code>inDateTime</code>
        property/relation is defined similarly to <code>hasDateTimeDescription</code>
        as follows:</p>
      <pre>:inDateTime
      a       owl:ObjectProperty ;
      rdfs:domain :Instant ;
      rdfs:range :DateTimeDescription .
</pre>
      <p>With this <code>inDateTime</code> relation, we can say that an instant
        happens at a specific time. For example, the beginning of a meeting,
        which is an instant, is at 6:00pm which is actually in a datetime
        interval of [6:00:00, 6:01:00). With <code>inDateTime</code> you do not
        describe instants; you only approximate them by confining them within an
        interval. This should generally be adequate. Where it is not, you can
        always define an instant in a roundabout way as the beginning of an
        interval.</p>
      <p><a  name="ref-datetime"></a>We also defined in OWL two simpler
        relations, <code>xsdDateTime</code> and <code>inXSDDateTime</code>.
        The only difference between these two relations and the above <code>hasDateTimeDescription</code>
        and <code>inDateTime</code> relations is their ranges: these two
        simpler relations use the XML Schema datatype <code>dateTime</code> as
        their ranges, while the above uses <code>DateTimeDescription</code>:</p>
      <pre>:xsdDateTime
      a       owl:DatatypeProperty ;
      rdfs:domain :DateTimeInterval ;
      rdfs:range xsd:dateTime .

:inXSDDateTime
      a       owl:DatatypeProperty ;
      rdfs:domain :Instant ;
      rdfs:range xsd:dateTime .
</pre>
      <p>To illustrate more clearly the difference between using <code>DateTimeDescription
          </code>and using the XML datatype <code>dateTime</code>, let’s look
        at a concrete example: an instant that represents the start of a meeing,
        called <code>meetingStart</code>, happens at 10:30am EST on 01/01/2006
        can be expressed using both <code>inXSDDateTime</code> and <code>inDateTime</code>
        in OWL as:</p>
      <pre>:meetingStart
      a       :Instant ;
      :inDateTime
              :meetingStartDescription ;
      :inXSDDateTime
              2006-01-01T10:30:00-5:00 .

:meetingStartDescription
      a       :DateTimeDescription ;
      :unitType :unitMinute ;
      :minute 30 ;
      :hour 10 ;
      :day 1 ;
      :dayOfWeek :Sunday ;
      :dayOfYear 1 ;
      :week 1 ;
      :month 1 ;
      :timeZone tz-us:EST ;
      :year 2006 .</pre>
      <p>We can see from this example that it’s much more concise to use the XML
        Schema datatype <code>dateTime</code>. However, the advantage of using
        <code>DateTimeDescription </code>is that it can express more
        information than <code>dateTime</code>, such as "week", "day of week"
        and "day of year", so in the above example, we can also know that
        01/01/2006 is Sunday, on the first day of the year, and in the first
        week of the year. </p>
      <p>The namespace “tz-us” points to our US time zone data [<a  href="#ref-17">17</a>].
        Moreover, each field of <code>DateTimeDescription </code>is separate
        so that it's easier to extract the value of some fields for the later
        use and easier to reason about.</p>
      <section  id="time-ontology-code">
        <h3>OWL code for the time ontology </h3>
        <p>[<a  href="/2006/time">RDF/XML</a>] </p>
      </section>
    </section>
    <section  id="ref-time-in-owl-s">
      <h2>Use Cases for Web Services</h2>
      <p>Congo.com and Bravo Air are the two examples used in the OWL-S 0.9
        draft release [<a  href="#ref-12">12</a>] (the most recent release is
        OWL-S 1.1 [<a  href="#ref-13">13</a>], and we use code in 0.9 draft
        release here for illustrative purpose). Congo.com is a fictitious
        book-selling service site, and Bravo Air is a fictitious
        airline-ticketing service site. We use these two examples to demonstrate
        in detail how the time ontology can be used to support OWL-S, including
        use cases for defining input parameters and (conditional) output
        parameters. </p>
      <section  id="input">
        <h3>Use Cases for Input Parameters</h3>
        <p>In the profile of the Congo.com example (i.e. CongoProfile.owl), for
          example, our time ontology is currently used for describing the input
          parameter <code>CreditCardExpirationDate</code>:</p>
        <pre>profile:CreditCardExpirationDate
      a       profile:ParameterDescription ;
      profile:parameterName
              creditCardExpirationDate ;
      profile:restrictedTo
              time:<b>Instant</b> ;
      profile:referTo
              congoProcess:creditCardExpirationDate .</pre>
        <p>The namespace “time” points to the location of the OWL code for the
          time ontology. In this example <code>Instant</code> is used to
          describe <code>CreditCardExpirationDate</code>, because the
          expiration date is actually an instant -- the midnight, of the day the
          credit card expires. </p>
        <p>In the Bravo Air example, our time ontology can be used to describe
          the existing input parameters, <code>DepartureDate</code> and <code>ArrivalDate</code>.
          We will change this to the more appropriate <code>DepartureTime</code>
          and <code>ArrivalTime</code>. We can define <code>DepartureTime</code>
          in the profile of the Bravo Air example (i.e. BravoAirProfile.owl) as:
        </p>
        <pre>profile:DepartureTime
      a       profile:ParameterDescription ;
      profile:parameterName
              DepartureTime ;
      profile:restrictedTo
              time:<b>Instant</b> ;
      profile:referTo
              ba_process:outboundDate_In .</pre>
        <p><code>DepartureTime</code> is defined as <code>Instant</code>. With
          this definition, as we discussed in the previous datetime description
          section, an instance of <code>DepartureTime</code> can has either an
          <code>inXSDDateTime</code> property/relation pointing to a specific
          value of XML Schema datatype dateTime, say 2006-01-01T10:30:00-5:00,
          or an <code>inDateTime</code> object-property/relation pointing to an
          instance of <code>DateTimeDescription</code> class specifying a
          specific time, say 10:30am EST on 01/01/2006, Sunday. It would be the
          user’s decision to define the time in either way based on the
          trade-offs discussed in the previous section.</p>
      </section>
      <section  id="output">
        <h3>Use Cases for (Conditional) Output Parameters</h3>
        <p>In fact, there is much more that our time ontology can do to support
          OWL-S. In the Congo.com and Bravo Air examples, the time ontology is
          not used for any output parameters. However, in the real world many
          service outputs are time-related. For example, in the Congo.com
          example we can add two outputs that are very common in real world
          book-selling sites: process time and delivery duration.</p>
        <section  id="ProcessTime">
          <h4>Adding a <code>ProcessTime</code> output parameter</h4>
          <p><code>ProcessTime</code> is a conditional output parameter that
            specifies how long before the book will be ready for delivery, say,
            24 hours, which depends on whether the book is in stock. In this use
            case, the process time is returned only if the book is in stock. It
            can be defined in the process model of the Congo.com example (i.e.
            CongoProcess.owl) as:</p>
          <pre>:ProcessTime
      a       owl:Class ;
      rdfs:subClassOf time:<b>Interval</b> .

:fullCongoBuyProcessTime
      a       rdf:Property ;
      rdfs:subPropertyOf process:output ;
      rdfs:domain :FullCongoBuy ;
      rdfs:range       
	      [ a       owl:Class ;
      		rdfs:subClassOf process:ConditionalOutput ;
      		rdfs:subClassOf
              		[ a       owl:Restriction ;
                	owl:allValuesFrom :BookInStock ;
                	owl:onProperty process:coCondition
              		] ;
	      ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:allValuesFrom :<b>ProcessTime</b> ;
                owl:onProperty process:coOutput
              ] .</pre>
          <p><code>ProcessTime</code> is defined as an interval, rather than a
            duration. As discussed previously, in our time ontology durations
            are properties of intervals. Thus to talk about a duration, i.e. a
            quantity of time, an interval must be defined first. This approach
            may look roundabout at first glance. However, the process time is
            not purely a quantity of time; it has a location on the time line.
            The beginning of the process time is the time the user places the
            order, and the end of the process time is the time the order is
            shipped out. An advantage of defining <code>ProcessTime</code> as
            an interval is that if the relationship among the order time, the
            shipping time, and the process time is known, any one of them (e.g.
            the shipping time) can be computed from the other two (e.g. the
            order time and the process time) by temporal arithmetic. </p>
        </section>
        <section  id="DeliveryDuration">
          <h4>Adding a <code>DeliveryDuration</code> output parameter</h4>
          <p><code>DeliveryDuration</code> is a conditional output parameter
            that specifies how long it will take for the customer to receive the
            book after it is shipped out, which depends on the delivery type the
            customer selects. As defined in the process model of the Congo.com
            example (i.e. CongoProcess.owl), the current delivery types are
            FedExOneDay, FedEx2-3day, UPS, and OrdinaryMail. </p>
          <p>To add this output parameter may seem similar to the above <code>ProcessTime</code>
            example. However, since an instance of <code>Condition</code> is a
            logical formula that evaluates to true or false (see the comment
            with the definition of Condition [<a  href="#ref-14">14</a>]), <code>DeliveryType</code>
            cannot be directly used as a condition to determine the delivery
            duration. Thus one property and one condition are defined for each
            delivery type. </p>
          <p><code>DeliveryDuration</code> is defined with two boundaries: one <code>minDeliveryDuration</code>
            and one <code>maxDeliveryDuration</code>. For example, an order
            with the FedEx2-3day delivery type takes 2 to 3 days, so its min
            delivery duration is 2 days, and its max delivery duration is 3
            days. For the delivery duration of the order with FedExOneDay
            delivery type, the min and max delivery duration will both be 1 day.
            We can define <code>DeliveryDuration</code> in the process model of
            the Congo.com example (i.e. CongoProcess.owl) as:</p>
          <pre>:DeliveryDuration
      a       owl:Class ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:cardinality 1 ;
                owl:onProperty :maxDeliveryDuration
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:cardinality 1 ;
                owl:onProperty :minDeliveryDuration
              ] .

:maxDeliveryDuration
      a       rdf:Property ;
      rdfs:domain :DeliveryDuration ;
      rdfs:range time:<b>Interval</b> .

:minDeliveryDuration
      a       rdf:Property ;
      rdfs:domain :DeliveryDuration ;
      rdfs:range time:<b>Interval</b> .
</pre>
          <p>Both <code>minDeliveryDuration</code> and <code>maxDeliveryDuration
              </code>are defined as properties of <code>DeliveryDuration</code>.
            For the same reason discussed for the process time example, both
            properties use Interval as their ranges. The cardinality of 1 for
            both properties in the definition of <code>DeliveryDuration</code>
            indicates that an instance of <code>DeliveryDuration</code> must
            have one and only one property value for <code>minDeliveryDuration</code>
            and <code>maxDeliveryDuration </code>respectively. For example, in
            order to define delivery duration for FedEx2-3day, we have to first
            define a condition of FedEx2-3day being selected:</p>
          <pre>:FedEx2-3dayCondition
      a       owl:Class ;
      rdfs:subClassOf process:Condition .</pre>
          <p>Then we define an output property, called <code>deliverySelectFedEx2-3day</code>
            that is conditional on <code>FedEx2-3dayCondition</code> defined
            above:</p>
          <pre>:deliverySelectFedEx2-3day
      a       rdf:Property ;
      rdfs:subPropertyOf process:output ;      
      rdfs:domain :SpecifyDeliveryDetails ;
      rdfs:range 
      	      [ a       owl:Class ;
      	      	rdfs:subClassOf process:ConditionalOutput ;
      	      	rdfs:subClassOf
              	      	[ a       owl:Restriction ;
                      	owl:allValuesFrom :FedEx2-3dayDuration ;
                      	owl:onProperty process:coOutput
              	      	] ;
      	      	rdfs:subClassOf
              	      	[ a       owl:Restriction ;
                      	owl:allValuesFrom :FedEx2-3dayCondition ;
                      	owl:onProperty process:coCondition
              ] .</pre>
          <p>This definition says that <code>deliverySelectFedEx2-3day</code>
            is a conditional output, and if <code>FedEx2-3dayCondition</code>
            is true, an instance of <code>FedEx2-3dayDuration</code> class will
            be the output. <code>FedEx2-3dayDuration</code> is not defined yet.
            In order to define it, we have to define its min delivery duration,
            i.e. 2 days, and max delivery duration, i.e. 3 days. Since the range
            of <code>minDeliveryDuration</code> and <code>maxDeliveryDuration</code>
            is <code>Interval</code>, intervals with specific durations need to
            be created first. For <code>FedEx2-3dayDuration</code>, we need to
            define <code>Interval2Days</code> and <code>Interval3Days</code>
            first as follows:</p>
          <pre>:Interval2Days
      a       owl:Class ;
      rdfs:subClassOf time:<b>Interval</b> ;
      owl:subClassOf
              [ a       owl:Restriction ;
                owl:hasValue P2D ;
                owl:onProperty time:<b>durationDescriptionDataType</b>
              ] .

:Interval3Days
      a       owl:Class ;
      rdfs:subClassOf time:<b>Interval</b> ;
      owl:subClassOf
              [ a       owl:Restriction ;
                owl:hasValue P3D ;
                owl:onProperty time:<b>durationDescriptionDataType</b>
              ] .</pre>
          <p>These two definitions use <code>durationDescriptionDataType</code>,
            a relatively simpler duration property of <code>Interval</code>
            using the XML Schmea datatype <code>duration</code> as its range. <code>P2D</code>
            and <code>P3D</code> are values of the XML Schema datatype <code>duration</code>,
            meaning 2 days and 3 days.</p>
          <p>Finally, <code>FedEx2-3dayDuration</code> restricts the value of <code>minDeliveryDuration</code>
            and <code>maxDeliveryDuration</code> to class <code>Interval2Days</code>
            and <code>Interval3Days</code> respectively as follows:</p>
          <pre>:FedEx2-3dayDuration
      a       owl:Class ;
      rdfs:subClassOf :DeliveryDuration ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:allValuesFrom :Interval3Days ;
                owl:onProperty :maxDeliveryDuration
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:allValuesFrom :Interval2Days ;
                owl:onProperty :minDeliveryDuration
              ] .</pre>
          <p>Properties to output delivery durations when the user selects other
            delivery types (FedExOneDay, UPS, and OrdinaryMail) can be defined
            similarly.</p>
        </section>
        <section  id="time-in-owls-09">
          <h4>OWL code for these examples</h4>
          <p>[<a  href="time-in-owls-09">RDF/XML</a>] </p>
        </section>
      </section>
    </section>
    <section  id="scheduling">
      <h2>A Use Case for Scheduling</h2>
      <p  id="examples0">Suppose someone has a telecon scheduled for 6:00pm EST
        on November 5, 2006. You would like to make an appointment with him for
        2:00pm PST on the same day, and expect the meeting to last 45
        minutes.&nbsp; Will there be an overlap? </p>
      <p>In this use case we can specify the facts about the telecon and the
        meeting using our ontology in OWL that will allow a temporal reasoner to
        determine whether there is a conflict:</p>
      <pre>:telecon
      a       :Interval ;
      :hasBeginning :teleconStart .
      
:meeting
      a       :Interval ;
      :hasBeginning :meetingStart ;
      :hasDurationDescription
              :meetingDuration .

:teleconStart
      a       :Instant ;
      :inXSDDateTime
              2006-11-05T18:00:00-5:00 .

:meetingStart
      a       :Instant ;
      :inXSDDateTime
              2006-11-05T14:00:00-8:00 .

:meetingDuration
      a       :DurationDescription ;
      :minutes 45 .
</pre>
      <p>The telecon and the meeting are defined as intervals. <code>hasBeginning</code>
        is used for specifying the start times of the meetings. The datetimes
        are specified using <code>inXSDDateTime</code>. The duration of the
        meeting is specified using the duration description class.</p>
    </section>
    <hr>
    <section  class="appendix"  id="summary">
      <h2>Summary of Classes and Properties in the Time Ontology</h2>
      <a  name="changes"></a>
      <section  id="changes">
        <h3>Classes (subclass relations)</h3>
        <ul>
          <li>TemporalEntity
            <ul>
              <li>Instant</li>
              <li>Interval
                <ul>
                  <li>ProperInterval
                    <ul>
                      <li>DateTimeInterval</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>DurationDescription</li>
          <li>DateTimeDescription</li>
          <li>TemporalUnit </li>
          <li>DayOfWeek</li>
        </ul>
      </section>
      <section  id="properties">
        <h3>Properties</h3>
        <table  id="table1">
          <tbody>
            <tr>
              <th>Property Name</th>
              <th>Domain</th>
              <th>Range</th>
            </tr>
            <tr>
              <td>before</td>
              <td>TemporalEntity</td>
              <td>TemporalEntity</td>
            </tr>
            <tr>
              <td>after</td>
              <td>TemporalEntity</td>
              <td>TemporalEntity</td>
            </tr>
            <tr>
              <td>hasBeginning</td>
              <td>TemporalEntity</td>
              <td>Instant </td>
            </tr>
            <tr>
              <td>hasEnd</td>
              <td>TemporalEntity</td>
              <td>Instant</td>
            </tr>
            <tr>
              <td>inside</td>
              <td>Interval</td>
              <td>Instant</td>
            </tr>
            <tr>
              <td>intervalEquals</td>
              <td>ProperInterval</td>
              <td>ProperInterval</td>
            </tr>
            <tr>
              <td>intervalBefore</td>
              <td>ProperInterval</td>
              <td>ProperInterval</td>
            </tr>
            <tr>
              <td>intervalMeets</td>
              <td>ProperInterval</td>
              <td>ProperInterval</td>
            </tr>
            <tr>
              <td>intervalOverlaps</td>
              <td>ProperInterval</td>
              <td>ProperInterval</td>
            </tr>
            <tr>
              <td>intervalStarts</td>
              <td>ProperInterval</td>
              <td>ProperInterval</td>
            </tr>
            <tr>
              <td>intervalDuring</td>
              <td>ProperInterval</td>
              <td>ProperInterval</td>
            </tr>
            <tr>
              <td>intervalFinishes</td>
              <td>ProperInterval</td>
              <td>ProperInterval</td>
            </tr>
            <tr>
              <td>intervalAfter</td>
              <td>ProperInterval</td>
              <td>ProperInterval</td>
            </tr>
            <tr>
              <td>intervalMetBy</td>
              <td>ProperInterval</td>
              <td>ProperInterval</td>
            </tr>
            <tr>
              <td>intervalOverlappedBy</td>
              <td>ProperInterval</td>
              <td>ProperInterval</td>
            </tr>
            <tr>
              <td>intervalStartedBy</td>
              <td>ProperInterval</td>
              <td>ProperInterval</td>
            </tr>
            <tr>
              <td>intervalContains</td>
              <td>ProperInterval</td>
              <td>ProperInterval</td>
            </tr>
            <tr>
              <td>intervalFinishedBy</td>
              <td>ProperInterval</td>
              <td>ProperInterval</td>
            </tr>
            <tr>
              <td>years</td>
              <td>DurationDescription</td>
              <td>xsd:decimal</td>
            </tr>
            <tr>
              <td>months</td>
              <td>DurationDescription</td>
              <td>xsd:decimal</td>
            </tr>
            <tr>
              <td>weeks</td>
              <td>DurationDescription</td>
              <td>xsd:decimal</td>
            </tr>
            <tr>
              <td>days</td>
              <td>DurationDescription</td>
              <td>xsd:decimal</td>
            </tr>
            <tr>
              <td>hours</td>
              <td>DurationDescription</td>
              <td>xsd:decimal</td>
            </tr>
            <tr>
              <td>minutes</td>
              <td>DurationDescription</td>
              <td>xsd:decimal</td>
            </tr>
            <tr>
              <td>seconds</td>
              <td>DurationDescription</td>
              <td>xsd:decimal</td>
            </tr>
            <tr>
              <td>hasDurationDescription</td>
              <td>TemporalEntity</td>
              <td>DurationDescription</td>
            </tr>
            <tr>
              <td>unitType</td>
              <td>DateTimeDescription</td>
              <td>TemporalUnit</td>
            </tr>
            <tr>
              <td>year</td>
              <td>DateTimeDescription</td>
              <td>xsd:gYear</td>
            </tr>
            <tr>
              <td>month</td>
              <td>DateTimeDescription</td>
              <td>xsd:gMonth</td>
            </tr>
            <tr>
              <td>week</td>
              <td>DateTimeDescription</td>
              <td>xsd:nonNegativeInteger</td>
            </tr>
            <tr>
              <td>day</td>
              <td>DateTimeDescription</td>
              <td>xsd:gDay</td>
            </tr>
            <tr>
              <td>dayOfWeek</td>
              <td>DateTimeDescription</td>
              <td>DayOfWeek</td>
            </tr>
            <tr>
              <td>dayOfYear</td>
              <td>DateTimeDescription</td>
              <td>xsd:nonNegativeInteger</td>
            </tr>
            <tr>
              <td>hour</td>
              <td>DateTimeDescription</td>
              <td>xsd:nonNegativeInteger</td>
            </tr>
            <tr>
              <td>minute</td>
              <td>DateTimeDescription</td>
              <td>xsd:nonNegativeInteger</td>
            </tr>
            <tr>
              <td>second</td>
              <td>DateTimeDescription</td>
              <td>xsd:decimal</td>
            </tr>
            <tr>
              <td>timeZone</td>
              <td>DateTimeDescription</td>
              <td>tzont;TimeZone</td>
            </tr>
            <tr>
              <td>inDateTime</td>
              <td>Instant</td>
              <td>DateTimeDescription</td>
            </tr>
            <tr>
              <td>inXSDDateTime</td>
              <td>Instant</td>
              <td>xsd:dateTime</td>
            </tr>
            <tr>
              <td>hasDateTimeDescription</td>
              <td>DateTimeInterval</td>
              <td>DateTimeDescription</td>
            </tr>
            <tr>
              <td>xsdDateTime</td>
              <td>DateTimeInterval</td>
              <td>xsd:dateTime</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
    <section  class="appendix"  id="timezone">
      <h2>Time Zone Resource in OWL</h2>
      <p  id="timezones-owl">We have developed a time zone resource [<a  href="#ref-15">15</a>]
        in OWL for not only the US but also the entire world, including three
        parts: the time zone ontology file [<a  href="#ref-16">16</a>], the US
        time zone instance file [<a  href="#ref-17">17</a>], and the world time
        zone instance file [<a  href="#ref-18">18</a>]. </p>
      <p>The time zone ontology links a preliminary geographic ontology with a
        time ontology. It defines the vocabulary about regions, political
        regions (countries, states, counties, reservations, and cities), time
        zones, daylight saving policies, and the relationships between these
        concepts. Its instances also link to other existing data on the Web,
        such as FIPS 55 county instances [<a  href="#ref-19">19</a>], and ISO
        country instances [<a  href="#ref-20">20</a>].</p>
      <p>It can handle all the usual time zone and daylight savings cases. For
        example, Los Angles uses PST, the time offset from Coordinated Universal
        Time (UTC) is -8 hours, and it observed daylight savings from April 2 to
        October 29 in 2006. But it handles unusual cases as well. For example,
        in Idaho the northern part is in the Pacific zone, the southern part in
        the Mountain. The city of West Wendover, Nevada is in the Mountain time
        zone, while the rest of Nevada is in the Pacific. </p>
      <section  id="examples1">
        <h3>Use case examples</h3>
        <p  id="codesyntax0">Suppose someone has a telecon scheduled for 6:00pm
          EST on November 5, 2006. You would like to make an appointment with
          him for 2:00pm PST on the same day, and expect the meeting to last 45
          minutes. Will there be an overlap? In order to specify the facts about
          the telecon and the meeting and reason about the relation between
          them, a time zone ontology would be necessary to help a time ontology
          (e.g. OWL-Time) to resolve the time difference between EST and PST. [<a
             href="#ref-anti-use">Anticipated Use</a>] will be described in
          detail in a later section.</p>
      </section>
      <section  id="ontology">
        <h3>Time Zone Ontology</h3>
        <p>We take <code>PoliticalRegion</code> to be a subclass of <code>Region</code>
          with the following properties: </p>
        <ul>
          <li><b>name</b>: at most one string. </li>
        </ul>
        <ul>
          <li><b>hasParentRegion</b>: the parent political region. </li>
        </ul>
        <ul>
          <li><b>hasTimeZone</b>: at most three time zones. </li>
        </ul>
        <ul>
          <li><b>observesDaylightSavingsTime</b>: true if the region goes on
            daylight savings time, false otherwise. </li>
        </ul>
        <ul>
          <li><b>hasDaylightSavingsPolicy</b>: the daylight saving policy that
            the region uses. </li>
        </ul>
        <ul>
          <li><b>exceptionalRegion</b>: exceptional sub-political-regions that
            have different time zones and/or daylight saving time policies (e.g.
            West Wendover, Nevada). </li>
        </ul>
        <ul>
          <li><b>timeZonePart</b>: sub-non-political-regions that have different
            time zones and/or daylight saving time policies (e.g. two different
            time zone parts in Idaho County in Idaho State). </li>
        </ul>
        <p>This can be defined in OWL as:</p>
        <pre>:PoliticalRegion
      a       owl:Class ;
      rdfs:subClassOf :Region ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :name
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :hasParentRegion
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 3 ;
                owl:onProperty :hasTimeZone
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :observesDaylightSavingsTime
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :hasDaylightSavingsPolicy
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:minCardinality 0 ;
                owl:onProperty :exceptionalRegion
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:minCardinality 0 ;
                owl:onProperty :timeZonePart
              ] .</pre>
        <p>Countries, states, counties, cities, and reservations are all
          subclass of political regions with different range types for the <code>hasParentRegion</code>
          property.<br>
          <br>
          For example, <code>Country</code> and <code>State</code> can be
          defined in OWL as:</p>
        <pre>:Country
      a       owl:Class ;
      rdfs:subClassOf :PoliticalRegion .</pre>
        <pre>:State
      a       owl:Class ;
      rdfs:subClassOf :PoliticalRegion ;
      owl:subClassOf
              [ a       owl:Restriction ;
               owl:onProperty :hasParentRegion ; 
               owl:allValuesFrom :Country                 
              ] .</pre>
        Time zones have two properties:
        <ul>
          <li><b>name</b>: at most one string. </li>
        </ul>
        <ul>
          <li><b>GMToffset</b>: an XML Schema duration between -12 and +14
            hours.</li>
        </ul>
        <p>This can be defined in OWL as:</p>
        <pre>:TimeZone
      a       owl:Class ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :name
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :GMToffset
              ] .</pre>
        <p>We assume default reasoning is used for this ontology. When a
          political region lacks one of its properties, we will use the one from
          its parent region. Thus all political sub-regions of the United States
          get their <code>DaylightSavingsPolicy</code> values from that of the
          United States, provided their <code>observesDaylightSavingsTime</code>
          property is true. All counties in California get their <code>hasTimeZone</code>
          values from California, whereas the <code>hasTimeZone</code> value is
          specified for each county in Kentucky and not for the state as a
          whole, since it is split between the Eastern and Central time zones.
          When most of a region is in one time zone, and only some exceptional
          sub-regions are in different time zones or have different daylight
          savings time policies, we use <code>exceptionalRegion</code> to point
          to each exceptional sub-region, e.g. West Wendover, which is in the
          Mountain time zone, is an exception in Nevada, which is otherwise in
          the Pacific time zone. <a  name="ref-west-wen"></a>Here is the OWL
          code of Nevada and West Wendover in the US time zone instance file [<a
             href="#ref-17">17</a>]:</p>
        <pre>:us-states:NV
      a       :State ;
      :hasParentRegion iso:US;
      :hasTimeZone :<b>PST</b> ;
      :observesDaylightSavingsTime true ;
      :<b>exceptionalRegion</b> :<b>NVWestWendoverCity</b> .

:NVWestWendoverCity
      a       :City ;
      :name "West Wendover City" ;
      :stateOf us-states:NV ;
      :hasTimeZone :<b>MST</b> ;
      owl:sameIndividualAs
              &lt;<a  href="http://www.daml.org/2003/02/fips55/NV.owl#p83730">http://www.daml.org/2003/02/fips55/NV.owl#p83730</a>&gt; .</pre>
        <p>When different parts of the same county are in different time zones,
          the <code>hasTimeZone</code> is not specified for the county. Instead
          the <code>hasTimeZone</code> is specified for each part with
          different time zones, and the <code>timeZonePart</code> property is
          used to point to the parts from the county instance, e.g. the two
          different time zone parts in Idaho County, Idaho. Here is the OWL
          encoding of Idaho County, Idaho in our US time zone instance file [<a
             href="#ref-17">17</a>]:</p>
        <pre>:IDIdaho
      a       :County ;
      :name "Idaho County" ;
      :hasParentRegion
              us-states:ID ;
      :<b>timeZonePart</b>
              :<b>IDIdahoPST</b> , :<b>IDIdahoMST</b> ;
      owl:sameIndividualAs
              &lt;http://www.daml.org/2003/02/fips55/ID.owl#c049&gt; .</pre>
        <a  name="ontology0"></a><code>DaylightSavingsPolicy</code> has one
        property:
        <ul>
          <li><b>lastUpdated</b>: the time that the daylight savings policy was
            updated. </li>
        </ul>
        <p><code>EnumeratedDaylightSavingsPolicy</code>, a subclass of <code>DaylightSavingsPolicy</code>,
          has the following properties:</p>
        <ul>
          <li><b>DLSstartDate</b>: the date the region goes on daylight savings
            time. </li>
        </ul>
        <ul>
          <li><b>DLSendDate</b>: the date the region goes off daylight savings
            time.</li>
        </ul>
        <p>This can be defined in OWL as:</p>
        <pre>:EnumeratedDaylightSavingsPolicy
      a       owl:Class ;
      rdfs:subClassOf :DaylightSavingsPolicy ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :DLSendDate
              ] ;
      rdfs:subClassOf
              [ a       owl:Restriction ;
                owl:maxCardinality 1 ;
                owl:onProperty :DLSstartDate
              ] .</pre>
        <p><code>DLSstartDate</code> and <code>DLSendDate</code> properties
          have the range of xsd:date. In the current instance files, different
          daylight saving policies were only defined for year 2006 as instances
          of <code>EnumeratedDaylightSavingsPolicy</code>, e.g. <code>USA2006DLS</code>
          for the United States, and <code>EU2006DLS</code> for the European
          Union.&nbsp;</p>
        <p><a  name="ref-temp-agg-eg"></a>Alternatively, a temporal aggregates
          ontology in OWL-Time can be used to describe the daylight saving
          policies. For example, in the US daylight saving starts on "the first
          Sunday of every April", which can be expressed in OWL as:</p>
        <pre>:tseq
      a       :TemporalSeq ;
      :hasTemporalAggregateDescription
              :firstSunEveryApril .</pre>
        <pre>:tseq-everyApril
      a       :TemporalSeq ;
      :hasTemporalAggregateDescription
              :everyApril .</pre>
        <pre>:everyApril
      a       :TemporalAggregateDescription ;
      :hasTemporalUnit
              :unitMonth ;
      :hasithTemporalUnit 4 .

:firstSunEveryApril
      a       :TemporalAggregateDescription ;
      :hasContextTemporalSeq
              :tseq-everyApril ;
      :hasContextTemporalUnit
              :unitMonth ;
      :hasithTemporalUnit 7 ;
      :hasTemporalUnit
              :unitDay ;
      :hasPosition 1 .</pre>
        <p>This defines the desired temporal sequence <code>tseq</code> of
          class <code>TemporalSeq</code> which has a <code>hasTemporalAggregateDescription</code>
          property that points to a temporal aggregate description <code>firstSunEveryApril</code>
          that describes the temporal sequence. In order to describe this
          two-layered temporal sequence ("the first Sunday" of "every April"),
          the outside layer ("every April"), i.e. the context temporal sequence
          (<code>tseq-everyApril</code>), needs to be defined first. This
          context temporal sequence also has its own <code>hasTemporalAggregateDescription</code>
          property that points to <code>everyApril</code> which describes that
          it is the every 4th (<code>hasithTemporalUnit</code> of 4) month (<code>hasTemporalUnit</code>
          of <code>unitMonth</code>). The desired temporal sequence is then
          defined as "the first (<code>hasPosition</code> of 1) Sunday (<code>hasithTemporalUnit</code>
          of 7 and <code>hasTemporalUnit</code> of <code>unitDayOfWeek</code>)
          of every April (<code>hasContextTemporalSeq</code> of <code>tseq-everyApril</code>
          and <code>hasContextTemporalUnit</code> of <code>unitMonth</code>)".</p>
        <p>For details about the temporal aggregates ontology and its use case
          examples, please see [<a  href="#ref-6">6</a>,<a  href="#ref-7">7</a>].</p>
        <section  id="timezone-ont">
          <h4>OWL code for the time zone ontology </h4>
          <p>[<a  href="/2006/timezone">RDF/XML</a>]</p>
        </section>
      </section>
      <section  id="ref-anti-use">
        <h3>Anticipated Use</h3>
        <p>The expected input to the ontology is a location, e.g. a city, and
          the output will be its current time offset, say -6 hours, from the
          Greenwich Mean Time (GMT).<br>
          <br>
          The ontology would be used as follows: given an input location, we
          first find in the ontology the lowest-level political region
          containing this location, say a county, then go up along the political
          region hierarchy based on the <code>hasParentRegion</code> property
          to the top of the hierarchy, usually a country. Along the path to the
          top, we get all the available information from each node (region) in
          order to calculate the time offset from the GMT. The information
          includes the time zone this location is in, whether it uses Daylight
          Savings (DLS) time, and if it does, what the start and end dates are.
        </p>
        <p>However, flexible inputs and more efficiency are supported by using
          the <code>exceptionalRegion</code> and <code>timeZonePart</code>
          properties, i.e. the location input does not have to be as detailed as
          the lowest-level political region, especially because usually only the
          information about what state it is in would be enough to calculate the
          time offset from the GMT for the input location. </p>
        <p>If the input only says it's a location of a state without specifying
          the county or city it is in, then we can first go to its state and see
          whether we can find all the information we need there, i.e. time zone
          and daylight savings information. If the state doesn't have any <code>exceptionalRegion</code>’s,
          then we don't need any more inputs for this location, and can safely
          go up along the political region hierarchy to the top of the
          hierarchy, e.g. the country US, and get all the information we need
          along the way to calculate the time offset from the GMT for this
          location. If the state does have any <code>exceptionalRegion</code>’s,
          however, we have to check each exceptional region to see whether this
          location is in it or not, at this checking phase, more detailed
          information about this location may be needed, i.e. which
          county/city/reservation it is in. If it's in an exceptional county
          that further has <code>timeZonePart</code>’s, then even more detailed
          information is needed from the input, i.e. which time zone part the
          location is in within this county. When reaching a sub-region with no
          <code>exceptionalRegion</code>’s or <code>timeZonePart</code>’s, we
          know for sure that no more input location information is needed and
          it's safe to go up along the political region hierarchy to the top,
          and get all the information we need to calculate the time offset from
          the GMT for this location. <br>
          <br>
          For example, suppose the input location is a location in West
          Wendover, Nevada, but at first we only know it's in Nevada (please see
          the OWL code [<a  href="#ref-west-wen">in the previous section</a>]).
          In the ontology, we first find Nevada state, from which we see one
          exceptional region pointing to West Wendover City, then we ask for
          further input location information: which city is this location in?
          Say we get West Wendover City. Since it matches the exceptional
          region, we then go to the West Wendover City instance to get its time
          zone information, which is the Mountain time zone. Since there is no <code>exceptionalRegion</code>’s
          or <code>timeZonePart</code>’s in the West Wendover City instance,
          it's now safe for us to go up along the hierarchy to the top, the
          United States. Along the path, at Nevada State we learn this location
          uses DLS time, then at its parent region, the US, we learn the DLS
          policy used is USA2006DLS which specifies the start date of the DLS in
          2006 is 04/02/2006 and the end date is 10/29/2006. Based on our
          current time, e.g. 1:50pm on 09/06/2006, we know the current time
          offset from the GMT at this location is -7 hours. </p>
      </section>
    </section>
    <hr> <a  name="examples2"></a>
    <section  id="references">
      <h2>References</h2>
      <p><a  name="ref-1"></a>[1] Allen, J. F. 1984. Towards a general theory of
        action and time. <i>Artificial Intelligence </i>23, pp. 123-154.<br>
        <br>
        <a  name="ref-2"></a>[2] Allen, J. F. and Ferguson, G. 1997. Actions and
        events in interval temporal logic. In <i>Spatial and Temporal Reasoning</i>.
        O. Stock, ed., Kluwer, Dordrecht, Netherlands, 205-245.</p>
      <p><a  name="ref-3"></a>[3] Dawson, F. and Stenerson, D. 1998. Internet
        Calendaring and Scheduling Core Object Specification (iCalendar),
        RFC2445. <a  href="http://www.ietf.org/rfc/rfc2445.txt">http://www.ietf.org/rfc/rfc2445.txt</a></p>
      <p><a  name="ref-4"></a>[4] Hobbs, J. R. and Pan, F. 2004. An Ontology of
        Time for the Semantic Web. <i>ACM Transactions on Asian Language
          Processing (TALIP): Special issue on Temporal Information Processing</i>,
        Vol. 3, No. 1, March 2004, pp. 66-85. </p>
      <p><a  name="ref-5"></a>[5] Pan, F and Hobbs, J. R. 2004. Time in OWL-S.
        In <i>Proceedings of the AAAI Spring Symposium on Semantic Web Services</i>,
        Stanford University, CA, pp. 29-36.</p>
      <p><a  name="ref-6"></a>[6] Pan, F and Hobbs, J. R. 2005. Temporal
        Aggregates in OWL-Time. In <i> Proceedings of the 18th International
          Florida Artificial Intelligence Research Society Conference (FLAIRS)</i>,
        Clearwater Beach, Florida, pp. 560-565, AAAI Press. </p>
      <p><a  name="ref-7"></a> [7] Pan, F. 2005. A Temporal Aggregates Ontology
        in OWL for the Semantic Web. In <i>Proceedings of the AAAI Fall
          Symposium on Agents and the Semantic Web</i>, Arlington, Virginia, pp.
        30-37.&nbsp;</p>
      <p><a  name="ref-8"></a>[8] OWL code of the time ontology. <a  href="http://www.w3.org/2006/time">http://www.w3.org/2006/time</a><br>
        <br>
        <a  name="ref-9"></a>[9] OWL code of the entry sub-ontology of time. <a
           href="http://www.w3.org/2006/time-entry">http://www.w3.org/2006/time-entry</a></p>
      <p><a  name="ref-10"></a>[10] OWL-Time Homepage: <a  href="http://www.isi.edu/%7Epan/OWL-Time.html">http://www.isi.edu/~pan/OWL-Time.html</a><br>
        <br>
        <a  name="ref-11"></a>[11] OWL-S homepage. <a  href="http://www.daml.org/services/owl-s/">http://www.daml.org/services/owl-s/</a></p>
      <p><a  name="ref-12"></a>[12] OWL-S 0.9 release. <a  href="http://www.daml.org/services/daml-s/0.9/">http://www.daml.org/services/daml-s/0.9/</a></p>
      <p><a  name="ref-13"></a>[13] OWL-S 1.1 release. <a  href="http://www.daml.org/services/owl-s/1.1/">http://www.daml.org/services/owl-s/1.1/</a><br>
        <br>
        <a  name="ref-14"></a>[14] The process file of the OWL-S 0.9 release. <a
           href="http://www.daml.org/services/owl-s/0.9/Process.owl">http://www.daml.org/services/owl-s/0.9/Process.owl</a></p>
      <p><a  name="ref-15"></a>[15] The homepage of the time zone resource in
        OWL. <a  href="http://www.isi.edu/%7Epan/timezonehomepage.html">http://www.isi.edu/~pan/timezonehomepage.html</a><br>
        <br>
        <a  name="ref-16"></a>[16] The time zone ontology file. <a  href="http://www.w3.org/2006/timezone">http://www.w3.org/2006/timezone</a><br>
        <br>
        <a  name="ref-17"></a>[17] The US time zone instance file.<b> </b><a  href="http://www.w3.org/2006/timezone-us">http://www.w3.org/2006/timezone-us</a><br>
        <br>
        <a  name="ref-18"></a>[18] The world time zone instance file. <a  href="http://www.w3.org/2006/timezone-world">http://www.w3.org/2006/timezone-world</a><br>
        <br>
        <a  name="ref-19"></a>[19] FIPS 55 County instance file. <a  href="http://www.daml.org/2003/02/fips55/">http://www.daml.org/2003/02/fips55/</a><br>
        <br>
        <a  name="ref-20"></a>[20] ISO Country instance file. <a  href="http://www.daml.org/2001/09/countries/iso">http://www.daml.org/2001/09/countries/iso</a></p>
      <p><a  id="OWL-Time-2006"  name="OWL-Time-2006"></a>[21] Hobbs, J. R. and
        Pan, F. 2006. Time Ontology in OWL. W3C Working Draft <a  href="https://www.w3.org/TR/owl-time/">https://www.w3.org/TR/owl-time/</a></p>
    </section>
    <hr> <a  name="examples3"></a>
    <section  id="ack">
      <h2>Acknowledgements</h2>
      <p>The editors would like to thank Deborah McGuinness, Chris Welty, and
        the reviewers of the earlier versions of the doucment, i.e., Jeremy
        Carroll, John McClure, Libby Miller, and Guus Schreiber, for their very
        helpful feedbacks and comments to the document.</p>
    </section>
  </body>
</html>
