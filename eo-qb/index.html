<!DOCTYPE html>
<html>
  <head>
    <meta  content="text/html; charset=utf-8"  http-equiv="content-type">
    <meta  content="width=device-width,initial-scale=1"  name="viewport">
    <title>Publishing and Using Earth Observation Data with the RDF Data Cube and the Discrete Global Grid System</title>
    <script  class="remove"  src="http://www.w3.org/Tools/respec/respec-w3c-common"></script>
    <script  class="remove"  src="config.js"></script>
    <style  type="text/css">

 /* Styles to replicate key LODS styles */

 ul.hlist {
  list-style-type:none;
  background-color: #eee;
 }
 ul.hlist li {
  display:inline;
  margin-right: 1em;
  font-size:smaller;
 }
 .entity {
  border: 1px solid black;
  padding: 0.5em;
  margin-top: 0.5em;
 }
 .entity h4 {
  margin-top:0;
  }
 .entity dl {
  border: dashed thin black;
  border-width:1px 0;
  background-color:#eee;
  margin: 0 0.5em;
 }
 p.iri::before {
  content: "IRI: ";
  font-weight: bold;
  font-family:sans-serif;
 }
 p.iri {
  font-family:monospace;
 }
 span.logic {
  font-weight:bold;
  color:purple;
 }
 span.dotted {
  text-decoration-line:underline;
  text-decoration-style: dotted;
  text-decoration-color:black;
 }

 </style>
</head>
<body>
    <section  id="abstract">
      <p>This document describes how dense geospatial raster data can be represented using the W3C RDF Data Cube (QB)  ontology [vocab-data-cube] in concert with other popular ontologies including the W3C/OGC  Semantic Sensor Network ontology (SSN) [[vocab-ssn-20160531]], the W3C/OGC Time ontology (Time) [[owl-time]], the W3C Simple Knowledge Organisation System (SKOS) [[skos-reference]], PROV-O [[prov-o]] and the W3C/OGC QB4ST. It offers general methods supported by worked examples that focus on earth observation imagery.
	  
      Current triple stores, as the default database architecture for RDF, are not suitable  for storing voluminous data like imagery derived from Landsat satellite sensors. We show how SPARQL queries can be served through an OGC Discrete Global Grid System for observations, coupled with a triple store for observational metadata. 
	  
	  While the approach  may also be suitable for other forms of coverage data, we leave the  application to such data as an exercise for the reader.
      </p>
    </section>
    <section  id="sotd">
      <p><strong>For OGC</strong> This is a Public Draft of a document prepared
        by the Spatial Data on the Web Working Group (<a  href="http://www.opengeospatial.org/projects/groups/sdwwg">SDWWG</a>)
        — a joint W3C-OGC project (see <a  href="https://www.w3.org/2015/spatial/charter">charter</a>).
        The document is prepared following W3C conventions. The document is
        released at this time to solicit public comment.</p>
    </section>
    <section  id="Introduction"  class="informative">
      <h2>Introduction</h2>
      <p>Publishing data on the web using <a href="https://www.w3.org/standards/semanticweb/data">linked data</a>
      technologies makes it more accessible, easier to discover, and machine-readable.
      This format is appropriate for sparse statistical data, but publishers of denser coverage data
      (such as Landsat imagery) may be justifiably reluctant to embrace the size explosion that
      accompanies converting data to RDF. While such a conversion provides maximum machine-readability,
      most of the benefits of linked data can be realised with a compromise approach where only the
      metadata is expressed in RDF, or where the RDF is generated on-the-fly to service requests.</p>

      <p>This document will refer to extracts of a small example to illustrate the approach. The complete source file is the
      <a href="https://github.com/w3c/sdw/raw/gh-pages/eo-qb/ANU-LED-example.ttl">ANU-LED example</a>.</p>
      
      <div  class="issue"  data-number="99 "> Add references throughout </div>
    </section>
    <section  id="Datacube"  class="informative">
      <h2>The RDF Data Cube</h2>
      <p>The <a href="https://www.w3.org/TR/vocab-data-cube/">RDF Data Cube</a> is an existing standard for representing data as RDF.
         It is typically used for data that is associated with statistical regions (e.g. suburbs).
         Common practice includes using the SKOS vocabulary to define the concepts being measured
         [<a href="https://www.w3.org/TR/sdw-ucr/#ObservedPropertyInCoverage">Observed property in coverage</a>].
         The RDF data model allows the user to define all the relevant components of their data and the concept they measure;
         including &ldquo;attribute&rdquo; components (metadata like sensor, resolution, uncertainty
         [<a href="https://www.w3.org/TR/sdw-ucr/#QualityMetadata">Quality metadata</a>, <a href="https://www.w3.org/TR/sdw-ucr/#UncertaintyInObservations">Uncertainty in observations</a>] etc.),
         &ldquo;measure&rdquo; components (the data proper) and &ldquo;dimension&rdquo; components
         (the domain of the dataset e.g. the time and statistical region each datum refers to).
         These techniques can easily be adapted to coverages, as the data model is flexible enough to define the appropriate attributes.</p>
         
      <pre class="example">:lat a qb:DimensionProperty ;
    rdfs:subPropertyOf geo:lat .

:long a qb:DimensionProperty ;
    rdfs:subPropertyOf geo:long .

:time a qb:DimensionProperty ;
    rdfs:range xsd:dateTime ;
    qb:concept sdmx-concept:timePeriod .

:dataValue a qb:MeasureProperty ;
    rdfs:range xsd:integer ;
    qb:concept :reflectance ;
    qb:concept sdmx-concept:obsValue .
    
:resolution a qb:AttributeProperty ;
    rdfs:range :pixelsPerDegree .
    
:pixelsPerDegree rdf:type rdfs:Datatype ;
    owl:equivalentClass xsd:double .</pre>

      <p>The ontology <a href="http://w3c.github.io/sdw/qb4st/">QB4ST</a> extends the Data Cube for extra power when describing gridded data,
         by defining terms for spatial dimensions and temporal dimensions [<a href="https://www.w3.org/TR/sdw-ucr/#GeoreferencedData">Georeferenced spatial data</a>].
         Any number of such dimensions can be defined, allowing for 1D, 2D, 3D or 4D coverages [<a href="https://www.w3.org/TR/sdw-ucr/#3DSupport">Support for 3D</a>, <a href="https://www.w3.org/TR/sdw-ucr/#TimeSeries">Time series</a>, <a href="http://w3c.github.io/sdw/UseCases/SDWUseCasesAndRequirements.html#4DModelSpaceTime">4D model of space-time</a>].</p>
         
      <pre class="example">:lat a qb4st:SpatialDimension ;
    rdfs:subPropertyOf geo:lat ;
    qb4st:crs &lt;http://www.opengis.net/def/crs/EPSG/0/4326&gt; .

:long a qb4st:SpatialDimension ;
    rdfs:subPropertyOf geo:long ;
    qb4st:crs &lt;http://www.opengis.net/def/crs/EPSG/0/4326&gt; .

:time a qb:DimensionProperty, qb4st:TemporalProperty ;
    rdfs:range xsd:dateTime ;
    qb:concept sdmx-concept:timePeriod .</pre>

      <section  id="Metadata">
        <h3>Metadata and data</h3>
        <p>There is traditionally a distinction between data (the observations proper e.g. Landsat pixels) and metadata
           (which adds context to the observations e.g. resolution). In the linked data world, this distinction is not strict.
           However, it is still possible to separate the two in a typical Data Cube.</p>
            
        <p>The value of an RDF Data Cube component can be attached to each individual observation or to the dataset as a whole.
           Dataset-wide metadata can therefore be distinguished from the rest of the dataset, because it is attached to the dataset object.
           This also makes it easy to fetch the metadata alone with a SPARQL query. This dataset-wide description alone is already a useful
           (and web-of-data friendly) approach to publishing spatial data
           [<a href="https://www.w3.org/TR/sdw-ucr/#SpatialMetadata">Spatial metadata</a>].</p>
           
        <pre class="example">:exampleDataset a qb:DataSet, prov:Entity ;
    qb:structure :exampleStructure ;
    :instrument :OLI ;
    :satellite :landsat-8 ;
    :band "4" ;
    :coverageSpatialDomain "POLYGON((90 41.87, 93.33 41.87, 93.33 38.18, 90 38.18, 90 41.87))"^^ogc:wktLiteral ;
    :coverageTemporalDomain :timeDomain ;
    prov:wasGeneratedBy :ANU-led-resampling ;
    prov:wasDerivedFrom :AGDC .
    
:p1 a :Pixel ;
    qb:dataSet :exampleDataset ;
    :lat "90.5556";
    :long "41.2444";
    :time "2001-10-26T21:32:52"^^xsd:dateTime ;
    :dataValue "15"^^xsd:integer ;
    :resolution "2.7"^^:pixelsPerDegree ;
    :dggsCell "R00004" ;
    :bounds  "POLYGON((90.37 41.45, 90.74 41.45, 90.74 41.04, 90.37 41.04, 90.37 41.45))"^^ogc:wktLiteral ;
    prov:wasDerivedFrom :example-tile .</pre>
           
        <p>Using the RDF Data Cube also opens up the possibility of more detailed metadata, such as individually tracing
           the provenance of each observation. It is not practical to serve Landsat imagery with RDF metadata attached
           to each pixel. However, it is reasonable to attach such metadata to tiles of a certain size.
           Thus, the RDF data model can be used, as long as RDF Data Cube observations are whole tiles rather than individual pixels [<a href="https://www.w3.org/TR/sdw-ucr/#TilingSupport">Support for tiling</a>].
           
        <pre class="example">:dataValue a qb:MeasureProperty ;
    rdfs:range [owl:unionOf(xsd:anyURI xsd:integer)] ;
    qb:concept :reflectance ;
    qb:concept sdmx-concept:obsValue .
    
:s1 a :GridSquare ;
    qb:dataSet :exampleDataset ;
    :lat "91.6667";
    :long "40.0270";
    :time "2001-10-26T21:32:52"^^xsd:dateTime ;
    :dataValue "http://www.example.org/led-example-image-R000" ;
    :resolution "0.9"^^:pixelsPerDegree ;
    :dggsCell "R000" ;
    :dggsLevelSquare "3" ;
    :dggsLevelPixel "4" ;
    :bounds  "POLYGON((90 41.87, 93.33 41.87, 93.33 38.18, 90 38.18, 90 41.87))"^^ogc:wktLiteral ;
    prov:wasDerivedFrom :example-tile .</pre>
      </section>
      
    </section>
    <section  id="Spectrum"  class="informative">
      <h2>A spectrum of linkiness</h2>
      <p>In the ideal web of data, every single observation has a unique URI, can be queried using SPARQL, and have metadata attached to it.
         Upon hearing this, anyone familiar with Landsat data would be forgiven for rejecting the whole enterprise as entirely impractical.
         But all is not lost! Most of the benefits of linked data (namely, linkability, enhanced discoverability, machine-readability) can
         be realised by just publishing the dataset-wide metadata in this format. More linkiness provides diminishing returns along with increasing costs.
         It is up to the publisher to decide where along this spectrum is the compromise position appropriate for them.</p>

      <p>To charactise the spectrum, we can broadly define three applications of RDF for coverages.
         From most to least costly, these are: to store a coverage dataset, to serve a coverage (&ldquo;serialisation&rdquo;), and to describe the metadata of a coverage (&ldquo;description&rdquo;).</p>

      <section  id="Storing">
            <h3>Storing a coverage</h3>
            <p>RDF data is stored natively in a triple store. The Data Cube, and RDF in general, are too verbose to be viable for large coverages.</p>
      </section>

      <section  id="Serving">
          <h3>Serving a coverage</h3>
          <p>In this model, coverage data is stored in some more appropriate format (such as HDF5).
             Specialised middleware receives SPARQL queries from a client and responds by sending a response in dynamically-generated RDF.
             Such a response is fairly verbose, but the cost is much smaller than actually storing the whole coverage in RDF.
             Further optimisation is still necessary for this to be viable. It is possible to use tiles as the &ldquo;observations&rdquo; in the RDF datacube,
             rather than individual pixels [<a href="https://www.w3.org/TR/sdw-ucr/#TilingSupport">Support for tiling</a>].
             This significantly reduces the blowup that comes from encoding data as RDF [<a href="https://www.w3.org/TR/sdw-ucr/#Compressible">Compressible</a>].</p>

          <p>The advantage of serving a coverage in RDF is that the entire coverage, and individual tiles within it, become linkable
             [<a href="https://www.w3.org/TR/sdw-ucr/#Linkability">Linkability</a>];
             this could be a major contribution to the linked data web. With sufficiently advanced middleware, SPARQL queries over the dataset
             could be served just as if the data were stored in RDF, but for a fraction of the storage cost.
             The publisher can thus leverage the full power of linked data.</p>

          <p>It is common to want only a chunk of the data available. For example, all observations near (within 10km of) Canberra, in the past year.
             The RDF Data Cube provides only for &ldquo;slices&rdquo;&mdash;predefined chunks that hold one or more dimensions constant. Unfortunately, this is an area where the Data Cube is
             insufficiently powerful for coverages. When data is stored and served in some other format, it is up to the publisher to provide the consumer ways to
             acquire only certain chunks of the data. If serving coverage data using RDF, a possible approach is to use SPARQL queries to define the appropriate chunks
             [<a href="https://www.w3.org/TR/sdw-ucr/#ReferenceDataChunks">Reference data chunks</a>]
             (for example, a query returning all tiles of a certain resolution within a certain spatial rectangle).
             Even if using this method, publishers should still make it easy for a user to select chunks without the use of SPARQL,
             e.g. by providing an interface to generate the appropriate query using a few predefined operators.</p>
      </section>

      <section  id="Describing">
          <h3>Describing a coverage</h3>
          <p>A large portion of the benefits of linked data may be realised by describing only the metadata of a coverage in RDF.
             Then the dataset can be linked to [<a href="https://www.w3.org/TR/sdw-ucr/#Linkability">Linkability</a>], and its essential properties are naturally machine-readable [<a href="https://www.w3.org/TR/sdw-ucr/#Discoverability">Discoverability</a>, <a href="https://www.w3.org/TR/sdw-ucr/#MachineToMachine">Machine to machine</a>].
             The coverage itself can remain in whatever efficient format the publisher prefers.</p>

          <p>No matter what approach is taken, it should be as easy as possible
             for the user to grab <strong>just</strong> the metadata, without having to figure out how to write an appropriate query.
              The definition of a <code>qb:DataSet</code> and the associated <code>qb:DataStructureDefinition</code> can serve this role, but it is still up to the
             publisher to make it easy for the user to download those definitions. This is also the appropriate place to think
             about the experience of web crawlers on the publisher's webpage [<a href="https://www.w3.org/TR/sdw-ucr/#Crawlability">Crawlability</a>, <a href="https://www.w3.org/TR/sdw-ucr/#MachineToMachine">Machine to machine</a>].</p>

          <p>It is also helpful if the user can easily identify the domain of a coverage (the spatial and temporal area where measurements are taken)
             [<a href="https://www.w3.org/TR/sdw-ucr/#SpatialMetadata">Spatial metadata</a>].
             QB4ST does not currently have a term for that, but it may in the future.</p>
             
          <pre class="example">:exampleDataset a qb:DataSet, prov:Entity ;
    qb:structure :exampleStructure ;
    :instrument :OLI ;
    :satellite :landsat-8 ;
    :band "4" ;
    :coverageSpatialDomain "POLYGON((90 41.87, 93.33 41.87, 93.33 38.18, 90 38.18, 90 41.87))"^^ogc:wktLiteral ;
    :coverageTemporalDomain :timeDomain ;
    prov:wasGeneratedBy :ANU-led-resampling ;
    prov:wasDerivedFrom :AGDC .
    
    

:exampleStructure a qb4st:SpatioTemporalDSD ;
    qb:component :spatialDomainComponent ,
                 :temporalDomainComponent ,
                 :latitudeComponent ,
                 :longitudeComponent ,
                 :timeComponent ,
                 :satelliteComponent ,
                 :instrumentComponent ,
                 :bandComponent ,
                 :dataComponent ,
                 :dggsCellComponent ,
                 :dggsLevelSquareComponent ,
                 :dggsLevelPixelComponent ,
                 :resolutionComponent ,
                 :boundsComponent .

:spatialDomainComponent a qb4st:SpatialComponentSpecification ;
    qb:attribute :coverageSpatialDomain .
    
:temporalDomainComponent a qb4st:TemporalComponentSpecification ;
    qb:attribute :coverageTemporalDomain .

:latitudeComponent a qb4st:SpatialComponentSpecification ;
    qb:dimension :lat .

:longitudeComponent a qb4st:SpatialComponentSpecification ;
    qb:dimension :long .

:timeComponent a qb4st:TemporalComponentSpecification ;
    qb:dimension :time .

:satelliteComponent a qb:ComponentSpecification ;
    qb:attribute :satellite .

:instrumentComponent a qb:ComponentSpecification ;
    qb:attribute :instrument .

:bandComponent a qb:ComponentSpecification ;
    qb:attribute :band .

:dataComponent a qb:ComponentSpecification ;
    qb:measure :dataValue .

:dggsCellComponent a qb4st:SpatialComponentSpecification ;
    qb:dimension :dggsCell .

:dggsLevelSquareComponent a qb:ComponentSpecification ;
    qb:dimension :dggsLevelSquare .

:dggsLevelPixelComponent a qb:ComponentSpecification ;
    qb:dimension :dggsLevelPixel .

:resolutionComponent a qb:ComponentSpecification ;
    qb:attribute :resolution .

:boundsComponent a qb4st:SpatialComponentSpecification ;
    qb:attribute :bounds .
    
    
    
:coverageSpatialDomain a qb:AttributeProperty, qb4st:SpatialProperty ;
    rdfs:subPropertyOf :bounds .
    
:coverageTemporalDomain a qb:AttributeProperty, qb4st:TemporalProperty ;
    rdfs:range time:DateTimeInterval ;
    qb:concept sdmx-concept:timePeriod .

:lat a qb4st:SpatialDimension ;
    rdfs:subPropertyOf geo:lat ;
    qb4st:crs &lt;http://www.opengis.net/def/crs/EPSG/0/4326&gt; .

:long a qb4st:SpatialDimension ;
    rdfs:subPropertyOf geo:long ;
    qb4st:crs &lt;http://www.opengis.net/def/crs/EPSG/0/4326&gt; .

:time a qb:DimensionProperty, qb4st:TemporalProperty ;
    rdfs:range xsd:dateTime ;
    qb:concept sdmx-concept:timePeriod .

:satellite a qb:AttributeProperty ;
    rdfs:range ssn:Platform ;
    qb:concept sdmx-concept:collMethod .

:instrument a qb:AttributeProperty ;
    rdfs:range ssn:Sensor ;
    qb:concept sdmx-concept:collMethod .

:band a qb:AttributeProperty ;
    rdfs:range xsd:integer .

:dataValue a qb:MeasureProperty ;
    rdfs:range [owl:unionOf(xsd:anyURI xsd:integer)] ;
    qb:concept :reflectance ;
    qb:concept sdmx-concept:obsValue .

:dggsCell a qb4st:SpatialDimension ;
    qb4st:crs "rHEALPix WGS84 Ellipsoid" ;
    rdfs:range xsd:string ;
    qb:concept sdmx-concept:refArea .

:dggsLevelSquare a qb:DimensionProperty ;
    rdfs:range xsd:integer .

:dggsLevelPixel a qb:DimensionProperty ;
    rdfs:range xsd:integer .

:resolution a qb:AttributeProperty ;
    rdfs:range :pixelsPerDegree .

:bounds a qb:AttributeProperty, qb4st:SpatialProperty ;
    rdfs:subPropertyOf ogc:asWKT ;
    rdfs:domain :GridSquare ;
    qb4st:crs &lt;http://www.opengis.net/def/crs/EPSG/0/4326&gt; ;
    qb:concept sdmx-concept:refArea .</pre>
      </section>
    </section>
    
    <section  id="DGGS"  class="informative">
      <h2>Discrete Global Grid Systems</h2>
      
      <p>
      Discrete global grid systems are a family of spatial reference systems that subdivide the Earth's surface into a hierarchy of cells.
      Larger cells are subdivided into smaller cells deeper in the hierarchy.
      Instead of a latitude and longitude, a location is specified by a cell id. Smaller cells are more precise, 
      so choosing a cell forces the publisher to include a measure of uncertainty for any spatial measure.
      Cells are also appropriate units of tiling for gridded coverages. Each pixel in a tile covering a larger cell can represent a measurement made on a smaller cell.
      The OGC is currently in the process of <a href="http://www.opengeospatial.org/projects/groups/dggsswg">standardising</a> a method to represent DGGSs.
      </p>
      
      <p>
      The example in this document does not depend on the use of a DGGS.  However, the DGGS has some convenient properties that make it particularly suitable for a linked data representation.
      First, each DGGS cell has a unique identifier, so it is easy to generate natural URIs for each piece of data.
      Second, the DGGS we use (<a href="http://raichev.net/files/rhealpix_dggs_preprint.pdf">rHEALPix</a>) defines cell geometries so that cells at the same level of the hierarchy have equal areas.
      This makes rHEALPix a suitable format for storing multiple datasets at different resolutions, or several different resolution views of the same dataset.
      The equal-area constraint means different resolution pixels are directly comparable, and no resampling is required [<a href="https://www.w3.org/TR/sdw-ucr/#AvoidCoordinateTransformations">Avoid coordinate transformations</a>].
      Third, the hierarchical nature of the DGGS makes it natural to implement spatial optimisations when responding to queries, by pruning the tree early to eliminate whole regions of unpromising cells that fall outside the desired area.
      </p>

      <section  id="Implementation">
        <h3>Implementation</h3>

        <p>
            The ontology described in this document, and a SPARQL query system to
            retrieve satellite imagery based on latitude/longitude or DGGS cell
            IDs has been implemented as a proof of concept. This section briefly
            describes some of the strategies employed to make the implementation
            efficient. All code referenced here is available on <a
            href="https://github.com/ANU-Linked-Earth-Data">GitHub</a>
        </p>

        <p>
            As alluded to previously, scalable implementations of a data cube
            for Earth observations must grapple with the verbosity of RDF
            representations, relative to specialised formats like GeoTIFF. This
            precludes materialising the entire dataset as RDF, storing it on
            disk, and serving it using an off-the-shelf triple store. Instead,
            implementations must employ a &ldquo;virtual graph&rdquo;, which can
            be used to service SPARQL queries without materialising all triples
            at once.
        </p>

        <p>
            For the purpose of illustrating how triple stores service SPARQL
            queries&mdash;regardless of whether they are backed by virtual or
            materialsed graphs&mdash;consider the query below.
        </p>

        <pre class="example">SELECT ?s ?v WHERE {
    ?s a :egType ;
        rdfs:label "Example" ;
        :value ?v .
    FILTER (?v < 15)
}</pre>

        <p>
            The heart of the query above is a Basic Graph Pattern (BGP) which
            specifies the form which examined triples should take. In this case,
            the BGP contains three patterns. Written explicitly, they are:
        </p>

        <pre class="example">?s a :egType .
?s rdfs:label "Example" .
?s :value ?v .</pre>

        <p>
            A typical triple store will begin servicing the query above by
            iterating through each triple pattern in turn. First, a set of
            bindings for <code>?s</code> will be generated which are consistent
            with <code>?s a :egType</code>. That set of bindings will then be
            filtered by matching them against the pattern <code>?s rdfs:label
            "Example"</code>. The final <code>?s :value ?v</code> will further
            filter the bindings for <code>?s</code> by considering only subjects
            <code>?s</code> with a <code>:value</code> property; it will also
            introduce a corresponding set of bindings for <code>?v</code>.
            Having generated all bindings relevant to the BGP, a typical triple
            store will then apply the <code>FILTER</code> condition to each. This
            general approach works for both traditaional storage backends (like
            on-disk RDF databases) and non-traditional ones (like virtual
            graphs).
        </p>

        <p>
            There are a number of ways in which this naive, pattern-by-pattern
            approach can be improved. We have implemented two simple extensions:
        </p>

        <ol>
            <li>
                User-supplied triple patterns often generate useful constraints
                on the data returned by a SPARQL query. For example, the pattern
                <code>?s :dggsLevelSquare 5 .</code> might allow a virtual graph
                implementation to ignore all observations not corresponding to cells
                at the fifth level of the DGGS hierarchy. In a naive
                implementation, only one such constraint can be considered at a
                time; this makes heuristics like query ordering essential. In
                contrast, a virtual graph implementation can simultaneously
                consider <em>all</em> supplied constraints in conjunction. For
                instance, if the user specifies <code>?s :dggsLevelSquare 5;
                :etmBand 3</code>, then the virtual graph implementation can
                safely narrow its search to observations at level 5 of the DGGS
                hierarchy which correspond to Landsat's third ETM band.
            </li>
            <li>
                Consumers of spatial datasets typically want only a small
                spatial slice of the available data. In SPARQL, such a slice can
                be identified by a <code>FILTER</code> statement restricting the
                appropriate location properties. By inspecting the contents of
                <code>FILTER</code> statements, virtual graph implementations
                can preemptively narrow the set of bindings they generate to
                include only bindings which are spatially relevant. In general,
                this approach can yield excellent gains when the spatial extent
                of queries is small relative to the spatial extent of the
                overall dataset.
            </li>
        </ol>

        <p>
            These simple optimisations can improve query time substantially.
            Consider the following SPARQL query, which fetches the intensity
            (<code>?val</code>) and URI (<code>?s</code>) associated with each
            single-pixel observation in a satellite imagery database.
        </p>

        <pre class="example">SELECT DISTINCT ?s ?val WHERE {
    ?s a led:Pixel
        ; led:etmBand "1"^^xsd:int
        ; led:dggsLevelSquare "5"^^xsd:int
        ; led:latMin ?latMin
        ; led:longMax ?longMax
        ; led:value ?val.
    # Everything north-west of Parliament House
    FILTER (?latMin > -35.3082
        && ?longMax < 149.1244)
}</pre>

        <p>
            The above query was executed on a 500MB HDF5 dataset containing over
            4000 distinct observations. Repeating the query a thousand times
            with ten concurrent clients on a desktop machine yielded the
            following mean running times. The &ldquo;naive&rdquo; implementation
            simply iterates through the BGP specified above on a
            pattern-by-pattern basis, subsequently passing results to
            the SPARQL engine for evaluation against the filter constraint.
            &ldquo;Multiple pattern-matching&rdquo; corresponds to the first
            optimisation identified above, and &ldquo;additional spatial
            optimisations&rdquo; refers to a combination of the first and second
            optimisations.
        </p>

        <table>
            <tr>
                <th>Implementation</th>
                <th>Mean runtime (± standard deviation)</th>
            <tr>
                <td>Naive</th>
                <td>378ms (±65.5ms)</td>
            </tr>
            <tr>
                <td>
                    …with multiple-pattern matching
                </td>
                <td>
                    35ms (±22.2ms)
                </td>
            </tr>
            <tr>
                <td>
                    …with additional spatial optimisations
                </td>
                <td class="right">
                    17ms (±11.8ms)
                </td>
            </tr>
        </table>

        <p>
            &ldquo;Multiple-pattern matching&rdquo; is a relatively simple
            optimisation, yet is still sufficient to imrpove query performance
            tenfold. Accounting for the bounding box constraint specified in the
            query improves performance by a another factor of two. It is likely
            that further performance gains could be found with more
            sophisticated optimisations; in particular, servicing queries with
            spatial restrictions could be further imrpoved by employing an
            R-tree, or some other specialised spatial data structure.
        </p>

      </section>

    <div  class="issue"  data-number="98"> Could also point to the client implementation --with a screen dump and pointer to github code? The running implementation itself may be too long-term unstable to reference.</div>
    </section>

    <section  id="Ontologies"  class="informative">
      <h2>Use of existing ontologies</h2>

      <p>RDF makes it easy to re-use terms defined in external ontologies
         [<a href="https://www.w3.org/TR/sdw-ucr/#ReferenceExternalVocabularies">Reference external vocabularies</a>].
         Some of the most widely applicable are explained here. See the
         <a href="https://github.com/w3c/sdw/raw/gh-pages/eo-qb/ANU-LED-example.ttl">ANU-LED example</a>
         for some specific examples of these.</p>

      <p>Several ontologies are being looked at by the Spatial Data on the Web working group.
         The final best practice for using these ontologies will depend on the outputs of the group.</p>
         
      <div  class="issue"  data-number="100"> References to SNN, Latitude/Longitude, QB4ST, OWL-Time, and GeoSPARQL should be updated to reflect the outputs of the working group.
      </div>

      <section  id="SSN">
          <h3>SSN</h3>
          <p>The <a href="https://www.w3.org/TR/vocab-ssn/">semantic sensor network</a> ontology defines terms for describing the sensors used to collect the data
             [<a href="https://www.w3.org/TR/sdw-ucr/#SensorMetadata">Sensor metadata</a>].
             The <a href="https://github.com/w3c/sdw/raw/gh-pages/eo-qb/ANU-LED-example.ttl">ANU-LED example</a>
             illustrates a minimal description of Landsat 8 OLI observations using SSN
             [<a href="https://www.w3.org/TR/sdw-ucr/#SSNLikeRepresentation">SSN-like representation</a>].
             Much more detailed descriptions are possible. In particular, SSN description can be attached to individual tiles
             [<a href="http://w3c.github.io/sdw/UseCases/SDWUseCasesAndRequirements.html#QualityPerSample">Quality per sample</a>].</p>
             
          <pre class="example">:exampleDataset a qb:DataSet, prov:Entity ;
    qb:structure :exampleStructure ;
    :instrument :OLI ;
    :satellite :landsat-8 ;
    :coverageSpatialDomain "POLYGON((90 41.87, 93.33 41.87, 93.33 38.18, 90 38.18, 90 41.87))"^^ogc:wktLiteral .
    
:landsat-8 a ssn:Platform ;
    owl:sameAs cci-platform:plat_landsat_8 .

:OLI a ssn:Sensor ;
    ssn:onPlatform :landsat-8 ;
    ssn:hasMeasurementCapability :oli-capability ;
    ssn:observes :reflectance ;
    owl:sameAs cci-sensor:sens_oli .

:oli-capability a ssn:MeasurementCapability ;
    ssn:forProperty :reflectance .

:reflectance a ssn:Property, skos:Concept ;
    owl:sameAs sweet:Reflectance ;
    owl:sameAs cci-dataType:dtype_sr .</pre>
      </section>

      <section  id="PROV-O">
          <h3>PROV-O</h3>
          <p>The <a href="https://www.w3.org/TR/prov-o/">PROV-O</a> ontology allows the provenance of data to be traced
             [<a href="https://www.w3.org/TR/sdw-ucr/#Provenance">Provenance</a>].
             It provides terms for describing what entities the data is based on,
             what processes were used to convert those entities into each other and into the final data,
             and what individuals and organisations were responsible for these processes.
             PROV-O descriptions can be attached at the dataset level, or even at the individual
             observation/tile level to indicate precisely which source material each observation is derived from.</p>
             
          <pre class="example">:exampleDataset a qb:DataSet, prov:Entity ;
    qb:structure :exampleStructure ;
    prov:wasGeneratedBy :ANU-led-resampling ;
    prov:wasDerivedFrom :AGDC .
    
:ANU-led-resampling a prov:Activity ;
    prov:wasAssociatedWith :DmitryBrizhinev ;
    prov:used :AGDC .

:DmitryBrizhinev a prov:Agent, prov:Person ;
    foaf:givenName "Dmitry"^^xsd:string ;
    foaf:mbox      &lt;mailto:dmitry.brizhinev@anu.edu.au&gt; .

:AGDC a prov:Collection ;
    prov:wasAssociatedWith :GeoscienceAustralia ;
    prov:hadMember :example-tile .

:example-tile a prov:Entity ;
    prov:alternateOf &lt;http://dapds00.nci.org.au/thredds/catalog/rs0/tiles/EPSG4326_1deg_0.00025pixel/LS8_OLI_TIRS/148_-035/2016/catalog.html?dataset=rs0/tiles/EPSG4326_1deg_0.00025pixel/LS8_OLI_TIRS/148_-035/2016/LS8_OLI_TIRS_FC_148_-035_2016-01-12T23-55-57.tif&gt; .

:GeoscienceAustralia a prov:Agent, prov:Organization .

:s1 a :GridSquare ;
    qb:dataSet :exampleDataset ;
    :lat "91.6667";
    :long "40.0270";
    :dataValue "http://www.example.org/led-example-image-R000" ;
    prov:wasDerivedFrom :example-tile .</pre>
      </section>

      <section  id="LatLong">
          <h3>Latitude and longitude</h3>
          <p>The working group wishes to discourage unqualified uses of &ldquo;latitude&rdquo; and &ldquo;longitude&rdquo;.
             Most commonly, these terms refer to the WGS-84 Coordinate Reference System (CRS),
             but published data should always make its CRS explicit [<a href="https://www.w3.org/TR/sdw-ucr/#Georectification">Georectification</a>].
             In RDF, the <a href="https://www.w3.org/2003/01/geo/">WGS-84 geo vocabulary</a> is often used,
              with its provided <code>geo:lat</code> and <code>geo:long</code> properties.
             The working group intends to standardise better properties, which allow the use of other CRSs.
             Once these exist, they should always be used in place of the geo properties.
              QB4ST defines the <code>qb4st:crs</code> property which will inherit from those
             [<a href="https://www.w3.org/TR/sdw-ucr/#CRSDefinition">CRS definition</a>, <a href="https://www.w3.org/TR/sdw-ucr/#SpatialMetadata">Spatial metadata</a>].
             The RDF Data Cube and QB4ST make is easy to define several CRSs and use them simultaneously, providing clients with several views of the data [<a href="https://www.w3.org/TR/sdw-ucr/#MultipleCRS">Multiple CRSs</a>]. In the example below, a grid square can be identified by latitude and longitude of its centroid, by its boundary, or by its rHEALPix cell.</p>
             
          <pre class="example">:lat a qb4st:SpatialDimension ;
    rdfs:subPropertyOf geo:lat ;
    qb4st:crs &lt;http://www.opengis.net/def/crs/EPSG/0/4326&gt; .

:long a qb4st:SpatialDimension ;
    rdfs:subPropertyOf geo:long ;
    qb4st:crs &lt;http://www.opengis.net/def/crs/EPSG/0/4326&gt; .
    
:dggsCell a qb4st:SpatialDimension ;
    qb4st:crs "rHEALPix WGS84 Ellipsoid" ;
    rdfs:range xsd:string .
    
:bounds a qb:AttributeProperty, qb4st:SpatialProperty ;
    rdfs:subPropertyOf ogc:asWKT ;
    qb4st:crs &lt;http://www.opengis.net/def/crs/EPSG/0/4326&gt; .
    
:latitudeComponent a qb4st:SpatialComponentSpecification ;
    qb:dimension :lat .

:longitudeComponent a qb4st:SpatialComponentSpecification ;
    qb:dimension :long .
    
:dggsCellComponent a qb4st:SpatialComponentSpecification ;
    qb:dimension :dggsCell .
    
:boundsComponent a qb4st:SpatialComponentSpecification ;
    qb:attribute :bounds .
    
:s1 a :GridSquare ;
    :lat "91.6667";
    :long "40.0270";
    :dggsCell "R000" ;
    :bounds  "POLYGON((90 41.87, 93.33 41.87, 93.33 38.18, 90 38.18, 90 41.87))"^^ogc:wktLiteral .</pre>
      </section>

      <section  id="GeoSPARQL">
          <h3>GeoSPARQL</h3>
          <p>The <a href="http://www.opengeospatial.org/standards/geosparql">GeoSPARQL</a> ontology [[GeoSPARQL]] defines some terms and predicates for reasoning about objects and shapes in space
             [<a href="https://www.w3.org/TR/sdw-ucr/#SpatialOperators">Spatial operators</a>].
             It allows for the use of several encodings, including WKT, to describe polygons
             [<a href="https://www.w3.org/TR/sdw-ucr/#EncodingForVectorGeometry">Encoding for vector geometry</a>].
             The ANU-LED example uses these terms to define the area covered by individual tiles in the coverage, and the entire spatial domain.</p>
             
          <pre class="example">:exampleDataset a qb:DataSet, prov:Entity ;
    qb:structure :exampleStructure ;
    :coverageSpatialDomain "POLYGON((90 41.87, 93.33 41.87, 93.33 38.18, 90 38.18, 90 41.87))"^^ogc:wktLiteral .

:bounds a qb:AttributeProperty, qb4st:SpatialProperty ;
    rdfs:subPropertyOf ogc:asWKT ;
    rdfs:domain :GridSquare ;
    qb4st:crs &lt;http://www.opengis.net/def/crs/EPSG/0/4326&gt; ;
    qb:concept sdmx-concept:refArea .

:s1 a :GridSquare ;
    qb:dataSet :exampleDataset ;
    :lat "91.6667";
    :long "40.0270";
    :dataValue "http://www.example.org/led-example-image-R000" ;
    :bounds  "POLYGON((90 41.87, 93.33 41.87, 93.33 38.18, 90 38.18, 90 41.87))"^^ogc:wktLiteral .</pre>
      </section>

      <section  id="SKOS">
          <h3>SKOS concepts</h3>
          <p>The Data Cube is commonly used in conjunction with a <a href="https://www.w3.org/TR/skos-reference/">SKOS</a> concept scheme
             (such as <a href="http://purl.org/linked-data/sdmx">SDMX-RDF</a> and its <a href="http://purl.org/linked-data/sdmx/2009/concept">concept scheme</a>)
             to define the meanings of the components [<a href="https://www.w3.org/TR/sdw-ucr/#ObservedPropertyInCoverage">Observed property in coverage</a>].
             It is appropriate to use this for coverages also, but appropriate SKOS concepts do not always exist.
             They may need to be published along with the data proper.</p>
             
          <pre class="example">:reflectance a ssn:Property, skos:Concept ;
    owl:sameAs sweet:Reflectance ;
    owl:sameAs cci-dataType:dtype_sr .
    
:time a qb:DimensionProperty, qb4st:TemporalProperty ;
    rdfs:range xsd:dateTime ;
    qb:concept sdmx-concept:timePeriod .

:satellite a qb:AttributeProperty ;
    rdfs:range ssn:Platform ;
    qb:concept sdmx-concept:collMethod .

:instrument a qb:AttributeProperty ;
    rdfs:range ssn:Sensor ;
    qb:concept sdmx-concept:collMethod .
    
:dataValue a qb:MeasureProperty ;
    rdfs:range [owl:unionOf(xsd:anyURI xsd:integer)] ;
    qb:concept :reflectance ;
    qb:concept sdmx-concept:obsValue .

:dggsCell a qb4st:SpatialDimension ;
    qb4st:crs "rHEALPix WGS84 Ellipsoid" ;
    rdfs:range xsd:string ;
    qb:concept sdmx-concept:refArea .</pre>
      </section>

      <section  id="OWL-Time">
          <h3>OWL-Time</h3>
          <p>Coverages should be annotated appropriately with the times observations were taken
             [<a href="https://www.w3.org/TR/sdw-ucr/#CoverageTemporalExtent">Coverage temporal extent</a>].
             <a href="https://www.w3.org/TR/owl-time/">OWL-Time</a> defines terms for time intervals that are useful for expressing the temporal domain of the dataset.
             It also allows temporal reference systems other than the Gregorian calendar.
             However, for Gregorian time instants, a datatype property using the built-in <code>xsd:dateTime</code> datatype is sufficient.
             </p>
             
          <p>QB4ST defines terms that work nicely with OWL-Time.</p>
             
          <pre class="example">:coverageTemporalDomain a qb:AttributeProperty, qb4st:TemporalProperty ;
    rdfs:range time:DateTimeInterval ;
    qb:concept sdmx-concept:timePeriod .
    
:time a qb:DimensionProperty, qb4st:TemporalProperty ;
    rdfs:range xsd:dateTime ;
    qb:concept sdmx-concept:timePeriod .
    
:exampleDataset a qb:DataSet, prov:Entity ;
    qb:structure :exampleStructure ;
    :coverageSpatialDomain "POLYGON((90 41.87, 93.33 41.87, 93.33 38.18, 90 38.18, 90 41.87))"^^ogc:wktLiteral ;
    :coverageTemporalDomain :timeDomain .

:timeDomain a time:Interval ;
    time:hasBeginning :timeBeginning ;
    time:hasEnd :timeEnd .
    
:timeBeginning a time:Instant ;
    time:inXSDDateTime "2001-10-26T21:32:52"^^xsd:dateTime .

:timeEnd a time:Instant ;
    time:inXSDDateTime "2001-10-26T21:32:52"^^xsd:dateTime .

:s1 a :GridSquare ;
    qb:dataSet :exampleDataset ;
    :time "2001-10-26T21:32:52"^^xsd:dateTime .</pre>
      </section>
    </section>
	
 <section class="appendix" id="acknowledgements">
  <h2>Acknowledgements</h2>
  <p>This spec would not be possible without the TechLauncher program of the Australian National University and its ardent convenor, Shayne Flint.
     We also thank Matthew Purss of Geoscience Australia for participating in the program and supporting this project.
     Finally, Ed Parsons of Google, Robert Woodcock of CSIRO, and Robert Atkinson of the OGC provided valuable discussions and feedback.
  </p>
</section>

 
	
   </body>
</html>
